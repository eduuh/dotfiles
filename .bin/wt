#!/usr/bin/env zsh
# wt - Git worktree manager for bare repo workflow
# Bare repos: ~/projects/bare/reponame.git
# Worktrees: ~/projects/worktree/reponame/branchname

set -e

source "$HOME/.bin/tmux/tmux-lib.sh"

# Repositories that should NOT be cloned as bare (regular clone instead)
# These repos will be cloned to ~/projects/reponame (without .git suffix)
REGULAR_CLONE_REPOS=(
    "dotfiles"
    "nvim"
    "personal-notes"
)

usage() {
    cat << EOF
Usage: wt <command> [args]

Commands:
  clone <url>              Clone repo (bare by default, some repos as regular)
  add [branch]             Add worktree (interactive if no branch specified)
  list                     List all worktrees for current repo
  remove [worktree]        Remove worktree (interactive if not specified)
  go [worktree]            cd to worktree (interactive if not specified)
  fetch                    Fetch all remotes for bare repo
  prune                    Prune stale worktree references

Examples:
  wt clone git@github.com:user/test.git    # Creates ~/projects/bare/test.git
  wt add main                              # Creates ~/projects/worktree/test/main
  wt add user/feature-x                    # Creates ~/projects/worktree/test/user-feature-x
  wt add -b new-feature main               # Create new branch from main
EOF
}

# Sanitize branch name for directory (replace / with -)
sanitize_branch() {
    echo "$1" | tr '/' '-'
}

# Check if repo should be cloned as regular (not bare)
is_regular_clone() {
    local repo_name="$1"
    for pattern in "${REGULAR_CLONE_REPOS[@]}"; do
        [[ "$repo_name" == "$pattern" ]] && return 0
    done
    return 1
}

# Find bare repo from current location
find_bare_repo() {
    local cwd="${1:-$(pwd)}"

    # If cwd is inside ~/projects/worktree/reponame/branch/, derive from .git file
    if [[ "$cwd" == "$WORKTREE_DIR"/* ]] && [[ -f "$cwd/.git" ]]; then
        local gitdir=$(cat "$cwd/.git" | sed 's/gitdir: //')
        # Resolve to absolute path if relative
        if [[ "$gitdir" != /* ]]; then
            gitdir="$cwd/$gitdir"
        fi
        # The gitdir points to bare/reponame.git/worktrees/<name>
        local bare_path=$(cd "$(dirname "$(dirname "$gitdir")")" 2>/dev/null && pwd)
        if [[ -d "$bare_path" && -f "$bare_path/HEAD" ]]; then
            echo "$bare_path"
            return 0
        fi
    fi

    # If cwd is inside ~/projects/bare/reponame.git
    if [[ "$cwd" == "$BARE_DIR"/*.git* ]]; then
        local bare_path="${cwd%%/.git*}"
        [[ "$bare_path" == "$BARE_DIR"/* ]] || bare_path="$cwd"
        if [[ -d "$bare_path" && -f "$bare_path/HEAD" ]]; then
            echo "$bare_path"
            return 0
        fi
    fi

    # Walk up from cwd looking for worktree indicator
    local dir="$cwd"
    while [[ "$dir" != "/" && "$dir" != "$HOME" ]]; do
        if [[ -f "$dir/.git" ]]; then
            local gitdir=$(cat "$dir/.git" | sed 's/gitdir: //')
            if [[ "$gitdir" != /* ]]; then
                gitdir="$dir/$gitdir"
            fi
            local bare_path=$(cd "$(dirname "$(dirname "$gitdir")")" 2>/dev/null && pwd)
            if [[ -d "$bare_path" && -f "$bare_path/HEAD" ]]; then
                echo "$bare_path"
                return 0
            fi
        fi
        dir=$(dirname "$dir")
    done

    return 1
}

# Get repo name from bare repo path
get_repo_name() {
    local bare_path="$1"
    basename "$bare_path" .git
}

# Clone a repo (bare by default, some repos as regular)
cmd_clone() {
    local url="$1"
    [[ -z "$url" ]] && { echo -e "${RED}Error: URL required${NC}"; usage; exit 1; }

    # Extract repo name from URL
    local repo_name=$(basename "$url" .git)

    # Check if this repo should be cloned as regular (not bare)
    if is_regular_clone "$repo_name"; then
        local clone_path="$PROJECT_ROOT/${repo_name}"

        if [[ -d "$clone_path" ]]; then
            echo -e "${RED}Error: $clone_path already exists${NC}"
            exit 1
        fi

        echo -e "${BLUE}Cloning $url as regular repo (not bare)...${NC}"
        git clone "$url" "$clone_path"

        echo -e "${GREEN}Cloned to $clone_path${NC}"
        echo -e "${YELLOW}This is a regular repo (not bare). Use standard git commands.${NC}"
    else
        local bare_path="$BARE_DIR/${repo_name}.git"

        if [[ -d "$bare_path" ]]; then
            echo -e "${RED}Error: $bare_path already exists${NC}"
            exit 1
        fi

        mkdir -p "$BARE_DIR" "$WORKTREE_DIR"

        echo -e "${BLUE}Cloning $url as bare repo...${NC}"
        git clone --bare "$url" "$bare_path"

        # Set up fetch to get all branches
        cd "$bare_path"
        git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
        git fetch origin

        # Auto-create default branch worktree
        local default_branch=$(git symbolic-ref --short HEAD 2>/dev/null || echo "main")
        local wt_path="$WORKTREE_DIR/${repo_name}/${default_branch}"
        mkdir -p "$WORKTREE_DIR/${repo_name}"

        echo -e "${BLUE}Creating worktree for $default_branch...${NC}"
        git worktree add "$wt_path" "$default_branch"

        echo -e "${GREEN}Cloned to $bare_path${NC}"
        echo -e "${GREEN}Worktree: $wt_path${NC}"
        echo -e "cd $wt_path"
    fi
}

# Add a worktree
cmd_add() {
    local bare_repo=$(find_bare_repo)

    # If not in a repo context, let user select from bare repos
    if [[ -z "$bare_repo" ]]; then
        local bare_repos=("$BARE_DIR"/*.git(N/))
        if [[ ${#bare_repos[@]} -eq 0 ]]; then
            echo -e "${RED}Error: No bare repos found in $BARE_DIR${NC}"
            exit 1
        fi

        echo -e "${BLUE}Select bare repo:${NC}"
        bare_repo=$(printf '%s\n' "${bare_repos[@]}" | fzf --reverse)
        [[ -z "$bare_repo" ]] && exit 0
    fi

    local repo_name=$(get_repo_name "$bare_repo")

    local branch="$1"
    local create_new=false
    local base_branch=""

    # Handle -b flag for new branch
    if [[ "$branch" == "-b" ]]; then
        create_new=true
        branch="$2"
        base_branch="$3"
    fi

    # Interactive branch selection if not specified
    if [[ -z "$branch" ]]; then
        echo -e "${BLUE}Select branch to checkout:${NC}"
        branch=$(git --git-dir="$bare_repo" branch -a --format='%(refname:short)' | \
            sed 's|^origin/||' | sort -u | grep -v '^HEAD$' | \
            fzf --reverse --header="Select branch")
        [[ -z "$branch" ]] && exit 0
    fi

    local sanitized=$(sanitize_branch "$branch")
    local worktree_path="$WORKTREE_DIR/${repo_name}/${sanitized}"

    if [[ -d "$worktree_path" ]]; then
        echo -e "${YELLOW}Worktree already exists: $worktree_path${NC}"
        echo -e "cd $worktree_path"
        exit 0
    fi

    mkdir -p "$WORKTREE_DIR/${repo_name}"

    echo -e "${BLUE}Creating worktree: $worktree_path${NC}"

    if $create_new; then
        [[ -z "$base_branch" ]] && base_branch="main"
        git --git-dir="$bare_repo" worktree add -b "$branch" "$worktree_path" "$base_branch"
    else
        # Check if branch exists locally or remotely
        if git --git-dir="$bare_repo" show-ref --verify --quiet "refs/heads/$branch"; then
            git --git-dir="$bare_repo" worktree add "$worktree_path" "$branch"
        elif git --git-dir="$bare_repo" show-ref --verify --quiet "refs/remotes/origin/$branch"; then
            git --git-dir="$bare_repo" worktree add "$worktree_path" "$branch"
        else
            echo -e "${YELLOW}Branch '$branch' not found. Creating new branch...${NC}"
            git --git-dir="$bare_repo" worktree add -b "$branch" "$worktree_path" "main"
        fi
    fi

    # Pull latest into the new worktree
    echo -e "${BLUE}Pulling latest...${NC}"
    git -C "$worktree_path" pull --ff-only 2>/dev/null || true

    echo -e "${GREEN}Created worktree: $worktree_path${NC}"
    echo -e "cd $worktree_path"
}

# List worktrees
cmd_list() {
    local bare_repo=$(find_bare_repo)

    if [[ -z "$bare_repo" ]]; then
        # List all worktrees for all bare repos
        echo -e "${BLUE}All worktrees:${NC}"
        for bare in "$BARE_DIR"/*.git(N/); do
            local name=$(basename "$bare" .git)
            echo -e "\n${YELLOW}$name:${NC}"
            git --git-dir="$bare" worktree list
        done
    else
        git --git-dir="$bare_repo" worktree list
    fi
}

# Remove a worktree
cmd_remove() {
    local worktree="$1"
    local bare_repo=$(find_bare_repo)

    if [[ -z "$worktree" ]]; then
        # Interactive selection
        local worktrees=()

        if [[ -n "$bare_repo" ]]; then
            worktrees=($(git --git-dir="$bare_repo" worktree list --porcelain | grep '^worktree' | cut -d' ' -f2))
        else
            # Gather from all bare repos
            for bare in "$BARE_DIR"/*.git(N/); do
                worktrees+=($(git --git-dir="$bare" worktree list --porcelain | grep '^worktree' | cut -d' ' -f2))
            done
        fi

        # Filter out bare repo paths (keep only worktree dirs)
        local wt_only=()
        for wt in "${worktrees[@]}"; do
            [[ "$wt" == "$BARE_DIR"/* ]] && continue
            wt_only+=("$wt")
        done
        worktrees=("${wt_only[@]}")

        [[ ${#worktrees[@]} -eq 0 ]] && { echo -e "${YELLOW}No worktrees found${NC}"; exit 0; }

        echo -e "${BLUE}Select worktree to remove:${NC}"
        worktree=$(printf '%s\n' "${worktrees[@]}" | fzf --reverse)
        [[ -z "$worktree" ]] && exit 0
    fi

    # Expand to full path if needed
    if [[ "$worktree" != /* ]]; then
        worktree="$WORKTREE_DIR/$worktree"
    fi

    if [[ ! -d "$worktree" ]]; then
        echo -e "${RED}Error: Worktree not found: $worktree${NC}"
        exit 1
    fi

    echo -e "${YELLOW}Removing worktree: $worktree${NC}"

    # Find the bare repo for this worktree
    local wt_bare=$(find_bare_repo "$worktree")
    if [[ -z "$wt_bare" ]]; then
        echo -e "${RED}Error: Could not find bare repo for worktree${NC}"
        exit 1
    fi

    git --git-dir="$wt_bare" worktree remove "$worktree"

    # Clean up empty repo directory
    local repo_dir=$(dirname "$worktree")
    if [[ "$repo_dir" == "$WORKTREE_DIR"/* ]] && [[ -d "$repo_dir" ]]; then
        rmdir "$repo_dir" 2>/dev/null || true
    fi

    echo -e "${GREEN}Removed worktree${NC}"

    # Close any orphaned branch notes
    "$HOME/.bin/branch-note.sh" prune
}

# Go to a worktree (for shell functions)
cmd_go() {
    local worktree="$1"

    if [[ -z "$worktree" ]]; then
        # Interactive selection from all worktrees
        local worktrees=()
        for repo_dir in "$WORKTREE_DIR"/*(N/); do
            local repo_name=$(basename "$repo_dir")
            for branch_dir in "$repo_dir"/*(N/); do
                local branch_name=$(basename "$branch_dir")
                worktrees+=("${repo_name}/${branch_name}")
            done
        done

        [[ ${#worktrees[@]} -eq 0 ]] && { echo -e "${YELLOW}No worktrees found${NC}"; exit 0; }

        worktree=$(printf '%s\n' "${worktrees[@]}" | fzf --reverse --header="Select worktree")
        [[ -z "$worktree" ]] && exit 0
    fi

    local path="$WORKTREE_DIR/$worktree"
    [[ ! -d "$path" ]] && { echo -e "${RED}Error: $path not found${NC}"; exit 1; }

    # Output path for shell wrapper to cd
    echo "$path"
}

# Fetch all remotes
cmd_fetch() {
    local bare_repo=$(find_bare_repo)
    [[ -z "$bare_repo" ]] && { echo -e "${RED}Error: Not in a worktree context${NC}"; exit 1; }

    echo -e "${BLUE}Fetching all remotes...${NC}"
    git --git-dir="$bare_repo" fetch --all --prune
    echo -e "${GREEN}Fetch complete${NC}"
}

# Prune stale worktree references
cmd_prune() {
    local bare_repo=$(find_bare_repo)

    if [[ -z "$bare_repo" ]]; then
        echo -e "${BLUE}Pruning all bare repos...${NC}"
        for bare in "$BARE_DIR"/*.git(N/); do
            git --git-dir="$bare" worktree prune
        done
    else
        git --git-dir="$bare_repo" worktree prune
    fi

    echo -e "${GREEN}Pruned stale worktree references${NC}"
}

# Main
case "${1:-}" in
    clone)  shift; cmd_clone "$@" ;;
    add)    shift; cmd_add "$@" ;;
    list|ls) cmd_list ;;
    remove|rm) shift; cmd_remove "$@" ;;
    go)     shift; cmd_go "$@" ;;
    fetch)  cmd_fetch ;;
    prune)  cmd_prune ;;
    -h|--help|help|"") usage ;;
    *)      echo -e "${RED}Unknown command: $1${NC}"; usage; exit 1 ;;
esac
