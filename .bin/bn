#!/usr/bin/env zsh
# bn - Universal branch note resolver
# Usage:
#   branch-note                          # Ensure note exists, print dir path
#   branch-note --path                   # Print note dir path only (no create)
#   branch-note --cat [file]             # Print note.md contents (or specific file)
#   branch-note --edit [file]            # Open note.md in $EDITOR (or specific file)
#   branch-note add <section> <text>     # Add line to section
#   branch-note list [--all]             # List active notes (--all includes closed)
#   branch-note active                   # List active notes
#   branch-note close                    # Close current branch's note
#   branch-note prune                    # Close notes whose worktrees no longer exist
#   branch-note summary                  # Dashboard: open todos, blockers, per-branch detail
#   branch-note status                   # One-line status for current branch
#   branch-note todo                     # List open todos across all branches
#   branch-note refresh                  # Fetch, pull, build current branch
#   branch-note refresh-all              # Refresh all main worktrees
#   branch-note build-init               # Create build.sh for current repo
#   branch-note build-edit               # Open build.sh in $EDITOR
#   branch-note archive [--days N] [--dry-run]  # Archive old closed notes

source "$HOME/.bin/tmux-lib.sh"

NOTES_DIR="$HOME/projects/personal-notes/branch-notes"

# Create note from template if it doesn't exist
ensure_note() {
    local note_dir="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH"
    local note_file="$note_dir/note.md"
    if [[ ! -f "$note_file" ]]; then
        mkdir -p "$note_dir"
        cat > "$note_file" << EOF
---
repo: $NOTE_REPO
branch: $NOTE_BRANCH
created: $(date +%Y-%m-%d)
status: active
type:
collaborators: []
---

# $NOTE_REPO / $NOTE_BRANCH

## Goal


## Todos
- [ ]

## Blockers
-

## Decisions
-

## To Research
-

## Collaboration
-

## To Ask
-

---
## Windows
EOF
    fi
    ensure_build_sh "$NOTE_REPO"
}

# Create repo-level global note if it doesn't exist
ensure_global_note() {
    local note_file="$NOTES_DIR/$NOTE_REPO/note.md"
    if [[ ! -f "$note_file" ]]; then
        mkdir -p "$NOTES_DIR/$NOTE_REPO"
        cat > "$note_file" << EOF
---
repo: $NOTE_REPO
created: $(date +%Y-%m-%d)
status: active
---

# $NOTE_REPO (global)

## Goal


## Todos
- [ ]

## Blockers
-

## Decisions
-

## To Research
-

## Collaboration
-

## To Ask
-
EOF
    fi
}

# Read status from frontmatter (defaults to "active" if missing)
get_note_status() {
    local note_file="$1"
    local note_status
    note_status=$(sed -n '/^---$/,/^---$/{ /^status:/s/^status: *//p; }' "$note_file")
    echo "${note_status:-active}"
}

# Set status in frontmatter
set_note_status() {
    local note_file="$1" new_status="$2"
    if grep -q '^status:' "$note_file"; then
        sed -i '' "s/^status: .*/status: $new_status/" "$note_file"
    else
        # Insert status after created line
        sed -i '' "/^created:/a\\
status: $new_status" "$note_file"
    fi
}

# Resolve path to build.sh (always in main's note dir)
resolve_build_sh() {
    local repo="$1"
    echo "$NOTES_DIR/$repo/main/build.sh"
}

# Auto-placeholder marker (checked by build-init to allow overwrite)
_BUILD_SH_PLACEHOLDER_MARKER="# bn-placeholder: no build configured"

# Ensure a placeholder build.sh exists (created if missing)
ensure_build_sh() {
    local repo="$1"
    local build_sh
    build_sh=$(resolve_build_sh "$repo")
    if [[ ! -f "$build_sh" ]]; then
        mkdir -p "$(dirname "$build_sh")"
        cat > "$build_sh" << EOF
#!/usr/bin/env zsh
${_BUILD_SH_PLACEHOLDER_MARKER}
echo "No build commands configured yet."
EOF
        chmod +x "$build_sh"
    fi
}

# Run build.sh if it exists, with cwd set to given directory
run_build_sh() {
    local repo="$1" work_dir="$2"
    local build_sh
    build_sh=$(resolve_build_sh "$repo")
    if [[ -x "$build_sh" ]]; then
        echo "Running build.sh for $repo..."
        (cd "$work_dir" && "$build_sh")
        return $?
    fi
    return 0
}

# Map short section name to heading
section_heading() {
    case "$1" in
        todo|todos)         echo "## Todos" ;;
        blocker|blockers)   echo "## Blockers" ;;
        decision|decisions) echo "## Decisions" ;;
        research)           echo "## To Research" ;;
        collab)             echo "## Collaboration" ;;
        ask)                echo "## To Ask" ;;
        *) echo "" ;;
    esac
}

# Format line based on section type
format_line() {
    local section="$1" text="$2"
    case "$section" in
        todo|todos) echo "- [ ] $text" ;;
        *)          echo "- $text" ;;
    esac
}

# Insert a line into the correct section of a note
insert_into_section() {
    local note_file="$1" heading="$2" line="$3"

    local heading_line
    heading_line=$(grep -n "^${heading}$" "$note_file" | head -1 | cut -d: -f1)
    [[ -z "$heading_line" ]] && { echo "Section '$heading' not found in note" >&2; return 1; }

    local after_heading=$((heading_line + 1))
    local next_heading_rel
    next_heading_rel=$(tail -n +$after_heading "$note_file" | grep -n '^## \|^---$' | head -1 | cut -d: -f1)

    if [[ -n "$next_heading_rel" ]]; then
        local insert_at=$((heading_line + next_heading_rel - 1))
        # Insert blank line + content before the next heading
        perl -i -pe "print \"${line}\n\" if \$. == ${insert_at}" "$note_file"
    else
        echo "$line" >> "$note_file"
    fi
}

# Add a line to a section
cmd_add() {
    local section="$1"
    [[ -z "$section" ]] && { echo "Usage: branch-note add <section> <text>" >&2; exit 1; }
    shift
    local text="$*"
    [[ -z "$text" ]] && { echo "Usage: branch-note add <section> <text>" >&2; exit 1; }

    local heading
    heading=$(section_heading "$section")
    [[ -z "$heading" ]] && { echo "Unknown section: $section (use: todo, blocker, decision, research, collab, ask)" >&2; exit 1; }

    resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }
    ensure_note

    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    local line
    line=$(format_line "$section" "$text")

    insert_into_section "$note_file" "$heading" "$line"
    echo "Added to ${heading#\#\# }: $text"
}

# List notes across repos (active only by default)
cmd_list() {
    local show_all=false
    [[ "$1" == "--all" ]] && show_all=true

    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local found=false
    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        local note_status=$(get_note_status "$note_file")
        if ! $show_all && [[ "$note_status" == "closed" ]]; then
            continue
        fi

        found=true
        local note_dir=$(dirname "$note_file")
        local branch=$(basename "$note_dir")
        local repo=$(basename "$(dirname "$note_dir")")

        local type=""
        type=$(sed -n '/^---$/,/^---$/{ /^type:/s/^type: *//p; }' "$note_file")
        [[ -z "$type" ]] && type="-"

        local todos=0
        todos=$(grep -c '^\- \[ \]' "$note_file" 2>/dev/null || true)

        local created=""
        created=$(sed -n '/^---$/,/^---$/{ /^created:/s/^created: *//p; }' "$note_file")

        local note_status_tag=""
        [[ "$note_status" == "closed" ]] && note_status_tag=" (closed)"

        printf "%-30s %-12s %d todos  %s%s\n" "$repo/$branch" "$type" "$todos" "$created" "$note_status_tag"
    done

    $found || echo "No branch notes found"
}

# Close current branch's note
cmd_close() {
    resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }
    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    [[ ! -f "$note_file" ]] && { echo "No note for $NOTE_REPO/$NOTE_BRANCH" >&2; exit 1; }

    set_note_status "$note_file" "closed"
    echo "Closed note: $NOTE_REPO/$NOTE_BRANCH"
}

# Close notes whose worktrees no longer exist
cmd_prune() {
    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local closed=0
    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        local note_status=$(get_note_status "$note_file")
        [[ "$note_status" == "closed" ]] && continue

        local note_dir=$(dirname "$note_file")
        local branch=$(basename "$note_dir")
        local repo=$(basename "$(dirname "$note_dir")")

        # Only prune worktree-based repos (those with a bare repo)
        [[ ! -d "$BARE_DIR/${repo}.git" ]] && continue

        local worktree_path="$WORKTREE_DIR/${repo}/${branch}"
        if [[ ! -d "$worktree_path" ]]; then
            set_note_status "$note_file" "closed"
            echo "Closed: $repo/$branch (worktree removed)"
            closed=$((closed + 1))
        fi
    done

    (( closed == 0 )) && echo "Nothing to prune"

    # Auto-archive old closed notes
    cmd_archive
}

# Summary dashboard
cmd_summary() {
    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local total_todos=0
    local total_blockers=0
    local details=""
    local found=false

    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        local note_status=$(get_note_status "$note_file")
        [[ "$note_status" == "closed" ]] && continue

        found=true
        local note_dir=$(dirname "$note_file")
        local branch=$(basename "$note_dir")
        local repo=$(basename "$(dirname "$note_dir")")

        local type=""
        type=$(sed -n '/^---$/,/^---$/{ /^type:/s/^type: *//p; }' "$note_file")
        [[ -z "$type" ]] && type="-"

        local todos=0
        todos=$(grep -c '^\- \[ \]' "$note_file" 2>/dev/null || true)
        total_todos=$((total_todos + todos))

        # Count non-empty blocker lines
        local blockers=0
        blockers=$(awk '/^## Blockers$/{found=1; next} /^## |^---$/{found=0} found && /^- ./' "$note_file" | wc -l | tr -d ' ')
        total_blockers=$((total_blockers + blockers))

        # Build per-branch detail
        local header="\n$repo/$branch ($type, $todos todos"
        (( blockers > 0 )) && header="$header, $blockers blockers"
        header="$header)"

        local items=""
        # Collect open todos
        while IFS= read -r line; do
            [[ -n "$line" ]] && items="$items\n  ${line#- }"
        done <<< "$(grep '^\- \[ \]' "$note_file" 2>/dev/null)"

        # Collect blockers
        while IFS= read -r line; do
            [[ -n "$line" ]] && items="$items\n  [!] ${line#- }"
        done <<< "$(awk '/^## Blockers$/{found=1; next} /^## |^---$/{found=0} found && /^- ./' "$note_file" 2>/dev/null)"

        if (( todos > 0 )) || (( blockers > 0 )); then
            details="$details$header$items"
        fi
    done

    if $found; then
        echo "Open todos across all branches: $total_todos"
        echo "Blockers: $total_blockers"
        [[ -n "$details" ]] && print "$details"
    else
        echo "No branch notes found"
    fi
}

# Refresh current branch: fetch, pull, build
cmd_refresh() {
    resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }

    local bare_repo="$BARE_DIR/${NOTE_REPO}.git"
    local worktree_path
    worktree_path=$(pwd)

    if [[ -d "$bare_repo" ]]; then
        echo "Fetching origin for $NOTE_REPO..."
        git --git-dir="$bare_repo" fetch origin

        echo "Pulling $NOTE_BRANCH (ff-only)..."
        git -C "$worktree_path" pull --ff-only
    else
        # Regular repo (not bare)
        echo "Fetching origin for $NOTE_REPO..."
        git -C "$worktree_path" fetch origin

        echo "Pulling $NOTE_BRANCH (ff-only)..."
        git -C "$worktree_path" pull --ff-only
    fi

    run_build_sh "$NOTE_REPO" "$worktree_path"
    echo "Refresh complete: $NOTE_REPO/$NOTE_BRANCH"
}

# Refresh all main worktrees: parallel fetch (batched), sequential update+build
cmd_refresh_all() {
    local bare_repos=("$BARE_DIR"/*.git(N/))
    [[ ${#bare_repos[@]} -eq 0 ]] && { echo "No bare repos found"; exit 0; }

    local updated=0 skipped=0 failed=0
    local batch_size=4

    # Phase 1: batched parallel fetch (avoid SSH rate limits)
    echo -e "${BLUE}Fetching ${#bare_repos[@]} repos (batch size $batch_size)...${NC}"
    local count=0
    local pids=()
    for bare in "${bare_repos[@]}"; do
        git --git-dir="$bare" fetch origin 2>/dev/null &
        pids+=($!)
        count=$((count + 1))
        if (( count % batch_size == 0 )); then
            for pid in "${pids[@]}"; do wait "$pid" 2>/dev/null; done
            pids=()
        fi
    done
    # Wait for remaining
    for pid in "${pids[@]}"; do wait "$pid" 2>/dev/null; done
    echo -e "${GREEN}Fetch complete.${NC}"

    # Phase 2: sequential update + build
    for bare in "${bare_repos[@]}"; do
        local repo_name=$(basename "$bare" .git)
        local main_wt="$WORKTREE_DIR/${repo_name}/main"

        if [[ ! -d "$main_wt" ]]; then
            echo -e "  ${YELLOW}${repo_name}: no main worktree, skipping${NC}"
            skipped=$((skipped + 1))
            continue
        fi

        echo -e "  ${BLUE}${repo_name}: updating main...${NC}"

        if git -C "$main_wt" merge --ff-only origin/main 2>/dev/null; then
            if run_build_sh "$repo_name" "$main_wt"; then
                echo -e "  ${GREEN}${repo_name}: updated${NC}"
                updated=$((updated + 1))
            else
                echo -e "  ${RED}${repo_name}: build failed${NC}"
                failed=$((failed + 1))
            fi
        else
            echo -e "  ${RED}${repo_name}: pull failed (not fast-forwardable?)${NC}"
            failed=$((failed + 1))
        fi
    done

    echo ""
    echo -e "Summary: ${GREEN}$updated updated${NC}, ${YELLOW}$skipped skipped${NC}, ${RED}$failed failed${NC}"
}

# Create build.sh template for current repo
cmd_build_init() {
    resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }

    local build_sh
    build_sh=$(resolve_build_sh "$NOTE_REPO")

    if [[ -f "$build_sh" ]]; then
        if grep -q "$_BUILD_SH_PLACEHOLDER_MARKER" "$build_sh" 2>/dev/null; then
            echo "Replacing placeholder build.sh with full template..."
        else
            echo "build.sh already exists and has been customized: $build_sh" >&2
            echo "Use 'bn build-edit' to modify it." >&2
            exit 1
        fi
    fi

    mkdir -p "$(dirname "$build_sh")"
    cat > "$build_sh" << 'BUILDEOF'
#!/usr/bin/env zsh
set -e

# Build script for this repo — runs after worktree create and on refresh.
# Uncomment/modify the section that matches your project:

# --- Rust ---
# cargo build

# --- Node ---
# npm install

# --- Go ---
# go build ./...

# --- Make ---
# make

echo "Build complete."
BUILDEOF
    chmod +x "$build_sh"
    echo "Created: $build_sh"
    echo "Edit with: bn build-edit"
}

# Open build.sh in editor
cmd_build_edit() {
    resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }

    local build_sh
    build_sh=$(resolve_build_sh "$NOTE_REPO")

    if [[ ! -f "$build_sh" ]]; then
        echo "No build.sh for $NOTE_REPO. Create one with: bn build-init" >&2
        exit 1
    fi

    ${EDITOR:-nvim} "$build_sh"
}

# Status: one-line summary for current branch
cmd_status() {
    resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }
    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    if [[ ! -f "$note_file" ]]; then
        echo "$NOTE_REPO/$NOTE_BRANCH: no note"
        return
    fi

    local todos=0 blockers=0
    todos=$(grep -c '^\- \[ \]' "$note_file" 2>/dev/null || true)
    blockers=$(awk '/^## Blockers$/{found=1; next} /^## |^---$/{found=0} found && /^- ./' "$note_file" | wc -l | tr -d ' ')

    local parts=()
    (( todos > 0 )) && parts+=("${todos} todo$( (( todos != 1 )) && echo s)")
    (( blockers > 0 )) && parts+=("${blockers} blocker$( (( blockers != 1 )) && echo s)")
    if [[ ${#parts[@]} -eq 0 ]]; then
        echo "$NOTE_REPO/$NOTE_BRANCH: clear"
    else
        echo "$NOTE_REPO/$NOTE_BRANCH: ${(j:, :)parts}"
    fi
}

# Todo: list open todos across all active branches
cmd_todo() {
    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local found=false
    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        local note_status=$(get_note_status "$note_file")
        [[ "$note_status" == "closed" ]] && continue

        local todos=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && todos+=("$line")
        done <<< "$(grep '^\- \[ \]' "$note_file" 2>/dev/null)"

        [[ ${#todos[@]} -eq 0 ]] && continue

        found=true
        local note_dir=$(dirname "$note_file")
        local branch=$(basename "$note_dir")
        local repo=$(basename "$(dirname "$note_dir")")

        echo -e "${BLUE}${repo}/${branch}${NC}"
        for todo in "${todos[@]}"; do
            echo "  $todo"
        done
    done

    $found || echo "No open todos"
}

# Archive closed notes older than N days
cmd_archive() {
    local days=30
    local dry_run=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --days) days="$2"; shift 2 ;;
            --dry-run) dry_run=true; shift ;;
            *) echo "Unknown option: $1" >&2; exit 1 ;;
        esac
    done

    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local cutoff
    cutoff=$(date -v-${days}d '+%Y-%m-%d')

    local archived=0
    local -a affected_paths=()

    if $dry_run; then
        echo -e "${YELLOW}[DRY RUN — no changes will be made]${NC}"
        echo ""
    fi

    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        local note_status=$(get_note_status "$note_file")
        [[ "$note_status" != "closed" ]] && continue

        local created=$(sed -n '/^---$/,/^---$/{ /^created:/s/^created: *//p; }' "$note_file")
        [[ -z "$created" ]] && continue
        [[ "$created" > "$cutoff" ]] && continue

        local note_dir=$(dirname "$note_file")
        local branch=$(basename "$note_dir")
        local repo=$(basename "$(dirname "$note_dir")")

        local dest="$NOTES_DIR/archive/$repo/$branch"

        if [[ -d "$dest" ]]; then
            echo -e "${RED}Already exists, skipping: archive/$repo/$branch${NC}" >&2
            continue
        fi

        echo -e "${YELLOW}Archive: $repo/$branch${NC} (created $created)"

        if ! $dry_run; then
            mkdir -p "$(dirname "$dest")"
            mv "$note_dir" "$dest"
            archived=$((archived + 1))
            affected_paths+=("$repo/$branch")

            # Clean up empty repo dir
            local repo_dir="$NOTES_DIR/$repo"
            if [[ -d "$repo_dir" ]] && [[ -z "$(ls -A "$repo_dir")" ]]; then
                rmdir "$repo_dir"
            fi
        else
            archived=$((archived + 1))
        fi
    done

    echo ""
    if $dry_run; then
        echo -e "${GREEN}Would archive: $archived note(s)${NC}"
    else
        echo -e "${GREEN}Archived: $archived note(s)${NC}"

        # Auto-commit only the moved note directories
        if (( archived > 0 )); then
            for p in "${affected_paths[@]}"; do
                git -C "$NOTES_DIR" add -- "archive/$p"
                git -C "$NOTES_DIR" rm -r --cached --ignore-unmatch --quiet -- "$p"
            done
            git -C "$NOTES_DIR" diff --cached --quiet || {
                git -C "$NOTES_DIR" commit -m "archive ${archived} note(s)" >/dev/null
                echo -e "${GREEN}Committed to personal-notes${NC}"
            }
        fi
    fi
}

# Extract non-placeholder items from a named section of a note file.
# Todos:   skips bare "- [ ]" and "- [ ] test"
# Others:  skips bare "-" lines
# Prints one item per line; returns 1 if section is empty/missing.
_section_items() {
    local note_file="$1" heading="$2"
    local -a items
    # Capture lines between the heading and the next heading/frontmatter fence
    while IFS= read -r line; do
        [[ -n "$line" ]] && items+=("$line")
    done <<< "$(awk "/^${heading}\$/{found=1; next} /^## |^---\$/{found=0} found && /^- /" "$note_file" 2>/dev/null)"

    # Filter out placeholders
    local -a real
    for item in "${items[@]}"; do
        # Skip bare todo placeholder and bare bullet
        [[ "$item" =~ '^- \[ \]( test)?$' ]] && continue
        [[ "$item" == "-" ]] && continue
        real+=("$item")
    done

    (( ${#real[@]} == 0 )) && return 1
    for item in "${real[@]}"; do
        echo "  $item"
    done
}

# Remove placeholder lines from a note file:
#   todos:  bare "- [ ]" or "- [ ] test"
#   others: bare "-" lines
_clean_note() {
    local note_file="$1"
    local before after
    before=$(grep -cE '^- \[ \]( test)?$|^-$' "$note_file" 2>/dev/null || true)
    (( before == 0 )) && return 0
    sed -i '' -E '/^- \[ \]( test)?$/d; /^-$/d' "$note_file"
    after=$(grep -cE '^- \[ \]( test)?$|^-$' "$note_file" 2>/dev/null || true)
    echo "  Removed $(( before - after )) placeholder(s)"
}

# Strip placeholder lines from notes
cmd_clean() {
    local all=false
    [[ "${1:-}" == "--all" ]] && all=true

    if $all; then
        [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }
        local cleaned=0 note_status note_dir branch repo count
        for note_file in "$NOTES_DIR"/*/*/note.md(N); do
            note_status=$(get_note_status "$note_file")
            [[ "$note_status" == "closed" ]] && continue
            note_dir=$(dirname "$note_file")
            branch=$(basename "$note_dir")
            repo=$(basename "$(dirname "$note_dir")")
            count=$(grep -cE '^- \[ \]( test)?$|^-$' "$note_file" 2>/dev/null || true)
            (( count == 0 )) && continue
            echo "${repo}/${branch}:"
            _clean_note "$note_file"
            cleaned=$(( cleaned + count ))
        done
        (( cleaned == 0 )) && echo "No placeholders found" || print "\nTotal removed: $cleaned"
    else
        resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }
        local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md" count
        [[ ! -f "$note_file" ]] && { echo "No note for $NOTE_REPO/$NOTE_BRANCH" >&2; exit 1; }
        count=$(grep -cE '^- \[ \]( test)?$|^-$' "$note_file" 2>/dev/null || true)
        if (( count == 0 )); then
            echo "No placeholders in $NOTE_REPO/$NOTE_BRANCH"
        else
            echo "$NOTE_REPO/$NOTE_BRANCH:"
            _clean_note "$note_file"
        fi
    fi
}

# All active worktrees with todos, blockers, research, decisions, and questions
cmd_worktrees() {
    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local found=false total_todos=0 out
    local note_status note_dir branch repo created type meta todo_count
    local -a todos

    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        note_status=$(get_note_status "$note_file")
        [[ "$note_status" == "closed" ]] && continue

        found=true
        note_dir=$(dirname "$note_file")
        branch=$(basename "$note_dir")
        repo=$(basename "$(dirname "$note_dir")")
        created=$(sed -n '/^---$/,/^---$/{ /^created:/s/^created: *//p; }' "$note_file")
        type=$(sed -n '/^---$/,/^---$/{ /^type:/s/^type: *//p; }' "$note_file")

        todos=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && todos+=("$line")
        done <<< "$(_section_items "$note_file" "## Todos" 2>/dev/null)"

        todo_count=${#todos[@]}
        total_todos=$(( total_todos + todo_count ))

        meta="${created}"
        [[ -n "$type" ]] && meta="${meta}  ${type}"
        echo -e "${BLUE}${repo}/${branch}${NC}  ${meta}"

        if (( todo_count > 0 )); then
            echo -e "  ${YELLOW}Todos${NC}"
            for todo in "${todos[@]}"; do echo "$todo"; done
        fi

        out=$(_section_items "$note_file" "## Blockers") && {
            echo -e "  ${RED}Blockers${NC}"
            echo "$out"
        }
        out=$(_section_items "$note_file" "## To Research") && {
            echo -e "  ${GREEN}Research${NC}"
            echo "$out"
        }
        out=$(_section_items "$note_file" "## Decisions") && {
            echo -e "  ${YELLOW}Decisions${NC}"
            echo "$out"
        }
        out=$(_section_items "$note_file" "## To Ask") && {
            echo -e "  ${NC}To Ask${NC}"
            echo "$out"
        }
        echo ""
    done

    if $found; then
        echo -e "${GREEN}Total open todos: ${total_todos}${NC}"
    else
        echo "No active branch notes found"
    fi
}

# Repo-level global note (not branch-specific)
cmd_global() {
    resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }
    local subcmd="${1:-}"
    shift 2>/dev/null || true

    case "$subcmd" in
        --cat|"")
            ensure_global_note
            cat "$NOTES_DIR/$NOTE_REPO/note.md"
            ;;
        --edit)
            ensure_global_note
            ${EDITOR:-nvim} "$NOTES_DIR/$NOTE_REPO/note.md"
            ;;
        --path)
            echo "$NOTES_DIR/$NOTE_REPO"
            ;;
        add)
            local section="$1"; shift
            local text="$*"
            [[ -z "$section" || -z "$text" ]] && { echo "Usage: bn global add <section> <text>" >&2; exit 1; }
            local heading
            heading=$(section_heading "$section")
            [[ -z "$heading" ]] && { echo "Unknown section: $section" >&2; exit 1; }
            ensure_global_note
            local note_file="$NOTES_DIR/$NOTE_REPO/note.md"
            local line
            line=$(format_line "$section" "$text")
            insert_into_section "$note_file" "$heading" "$line"
            echo "Added to ${heading#\#\# } (global/$NOTE_REPO): $text"
            ;;
        *)
            echo "Usage: bn global [--cat|--edit|--path|add <section> <text>]" >&2
            exit 1
            ;;
    esac
}

# Main
case "${1:-}" in
    --path)
        resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }
        echo "$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH"
        ;;
    --cat)
        resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }
        local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
        # Auto-prune: if note is active, repo is bare-based, and worktree is gone
        if [[ -f "$note_file" && -d "$BARE_DIR/${NOTE_REPO}.git" ]]; then
            local wt_path="$WORKTREE_DIR/${NOTE_REPO}/${NOTE_BRANCH}"
            if [[ ! -d "$wt_path" ]] && [[ "$(get_note_status "$note_file")" == "active" ]]; then
                set_note_status "$note_file" "closed"
                echo "Auto-closed: $NOTE_REPO/$NOTE_BRANCH (worktree removed)" >&2
            fi
        fi
        local file="${2:-note.md}"
        cat "$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/$file"
        ;;
    --edit)
        resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }
        ensure_note
        local file="${2:-note.md}"
        ${EDITOR:-nvim} "$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/$file"
        ;;
    add)
        shift
        cmd_add "$@"
        ;;
    list)
        shift
        cmd_list "$@"
        ;;
    active)
        cmd_list
        ;;
    close)
        cmd_close
        ;;
    prune)
        cmd_prune
        ;;
    summary)
        cmd_summary
        ;;
    status)
        cmd_status
        ;;
    todo|todos)
        cmd_todo
        ;;
    refresh)
        cmd_refresh
        ;;
    refresh-all)
        cmd_refresh_all
        ;;
    build-init)
        cmd_build_init
        ;;
    build-edit)
        cmd_build_edit
        ;;
    archive)
        shift
        cmd_archive "$@"
        ;;
    clean)
        shift
        cmd_clean "$@"
        ;;
    worktrees)
        cmd_worktrees
        ;;
    global)
        shift
        cmd_global "$@"
        ;;
    -h|--help|help)
        cat << 'HELPEOF'
Usage: bn [command]

Commands:
  (none)                          Ensure note exists, print dir path
  --path                          Print note dir path (no create)
  --cat [file]                    Print note.md (or specific file)
  --edit [file]                   Open note in $EDITOR
  add <section> <text>            Add line to section
  list [--all]                    List active notes (--all includes closed)
  active                          List active notes (same as list)
  close                           Close current branch's note
  prune                           Close notes whose worktrees are gone
  summary                         Dashboard of active work
  status                          One-line status for current branch
  todo                            List open todos across all branches
  refresh                          Fetch, pull, build current branch
  refresh-all                      Refresh all main worktrees
  build-init                       Create build.sh template for repo (replaces placeholder)
  build-edit                       Open build.sh in \$EDITOR
  archive [--days N] [--dry-run]   Archive closed notes older than N days (default 30)
  clean [--all]                    Remove empty placeholder todos (current note, or all active)
  worktrees                        All active worktrees with their full todo lists
  global [--cat|--edit|--path]     Repo-level global note (not branch-specific)
  global add <section> <text>      Add to repo global note

Notes:
  A placeholder build.sh is auto-created on first note access.
  Use 'bn build-init' to replace it with a full template.

Sections: todo, blocker, decision, research, collab, ask
HELPEOF
        ;;
    "")
        resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }
        ensure_note
        echo "$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH"
        ;;
    *)
        echo "Unknown command: $1" >&2
        exit 1
        ;;
esac
