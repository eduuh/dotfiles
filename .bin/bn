#!/usr/bin/env zsh
# bn - Universal branch note resolver
# Usage:
#   bn                             # Ensure note exists, print dir path
#   bn --path|-p                    # Print note dir path only (no create)
#   bn --cat|-c [file]              # Print note.md contents (or specific file)
#   bn --edit|-e [file]             # Open note.md in $EDITOR (or specific file)
#   bn add|a <section> <text>       # Add line to section
#   bn list|l [--all]               # List active notes (--all includes closed)
#   bn active                       # List active notes
#   bn close                        # Close current branch's note
#   bn prune                        # Close notes whose worktrees no longer exist
#   bn summary|s                    # Dashboard: open todos, blockers, per-branch detail
#   bn status|st                    # One-line status for current branch
#   bn todo|t                       # List open todos across all branches
#   bn refresh|r                    # Fetch, pull, build current branch
#   bn refresh-all|ra               # Refresh all main worktrees
#   bn main|m                       # Print main note dir + list scripts
#   bn build|b [name]               # Run a script (default: build)
#   bn script|sc [new|edit|list]    # Manage repo scripts
#   bn files|f [name|new|edit]       # Investigation file management
#   bn archive [--days N] [--dry-run]  # Archive old closed notes
#   bn clean [--all]                # Remove empty placeholder todos
#   bn worktrees|w                  # All active worktrees with details
#   bn pr [url] [--copy|--show]     # Link/open PR for current branch
#   bn link|wi [id] [--copy|--show] # Link/open work item
#   bn diff|d                       # Git diff stat + open todos
#   bn global|g [subcmd]            # Repo-level global note

source "$HOME/.bin/tmux-lib.sh"

# --- Config ---

NOTES_DIR="$HOME/projects/personal-notes/branch-notes"
_HOSTNAME=$(hostname)

# --- Helpers: Git Context ---

# Resolve git context and exit on failure. Use instead of bare resolve_note_context.
require_git_context() {
    resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }
}

# --- Helpers: Git & Frontmatter ---

# Read a single frontmatter field from a note file (pure zsh, no subprocesses).
# Usage: _frontmatter_val "$note_file" "field_name"
# Sets REPLY; returns empty string if not found.
_frontmatter_val() {
    local in_front=false
    while IFS= read -r line; do
        if [[ "$line" == "---" ]]; then
            $in_front && break
            in_front=true
            continue
        fi
        $in_front && [[ "$line" == ${2}:* ]] && { REPLY="${line#${2}:}"; REPLY="${REPLY# }"; return 0; }
    done < "$1"
    REPLY=""
    return 1
}

# Read machine from frontmatter (empty if missing)
get_note_machine() {
    _frontmatter_val "$1" "machine"
    echo "$REPLY"
}

# Check if note belongs to current machine (notes without machine field always match)
is_local_note() {
    _frontmatter_val "$1" "machine"
    [[ -z "$REPLY" || "$REPLY" == "$_HOSTNAME" ]]
}

# Read status from frontmatter (defaults to "active" if missing)
get_note_status() {
    _frontmatter_val "$1" "status"
    echo "${REPLY:-active}"
}

# Set status in frontmatter
set_note_status() {
    local note_file="$1" new_status="$2"
    if grep -q '^status:' "$note_file"; then
        sed -i "s/^status: .*/status: $new_status/" "$note_file"
    else
        # Insert status after created line
        sed -i "/^created:/a\\
status: $new_status" "$note_file"
    fi
}

# Set any frontmatter field (adds after status: if missing)
_set_frontmatter() {
    local note_file="$1" key="$2" value="$3"
    if grep -q "^${key}:" "$note_file"; then
        sed -i "s|^${key}:.*|${key}: ${value}|" "$note_file"
    else
        sed -i "/^status:/a\\
${key}: ${value}" "$note_file"
    fi
}

# --- Helpers: Platform ---

# Open a URL in the default browser (macOS, WSL, Linux)
_open_url() {
    local url="$1"
    if command -v open &>/dev/null; then
        open "$url"
    elif command -v wslview &>/dev/null; then
        wslview "$url"
    elif command -v xdg-open &>/dev/null; then
        xdg-open "$url" 2>/dev/null &
    elif [[ -x /mnt/c/Windows/explorer.exe ]]; then
        /mnt/c/Windows/explorer.exe "$url"
    else
        echo "$url"
        return 1
    fi
}

# Copy text to clipboard (macOS, WSL, Linux)
_copy_to_clipboard() {
    local text="$1"
    if command -v pbcopy &>/dev/null; then
        echo -n "$text" | pbcopy
    elif command -v wl-copy &>/dev/null; then
        echo -n "$text" | wl-copy
    elif command -v xclip &>/dev/null; then
        echo -n "$text" | xclip -selection clipboard
    elif [[ -x /mnt/c/Windows/System32/clip.exe ]]; then
        echo -n "$text" | /mnt/c/Windows/System32/clip.exe
    else
        echo "$text"
        echo "(no clipboard tool found)" >&2
        return 1
    fi
}

# --- Helpers: Note Templates ---

TEMPLATE_DIR="$HOME/.config/bn/templates"

# Render a template file with {{VAR}} substitution.
# Usage: _render_template <template_name> [VAR=value ...]
# Falls back to inline heredoc if template file is missing.
_render_template() {
    local tmpl_name="$1"; shift
    local tmpl_file="$TEMPLATE_DIR/$tmpl_name"

    # Build sed substitution from args
    local -a subs
    for pair in "$@"; do
        local key="${pair%%=*}" val="${pair#*=}"
        subs+=("-e" "s|{{${key}}}|${val}|g")
    done

    if [[ -f "$tmpl_file" ]]; then
        sed "${subs[@]}" "$tmpl_file"
    else
        # Fallback: inline heredocs for backwards compat
        case "$tmpl_name" in
            branch-note.md) _branch_note_template_inline "${(@)@}" ;;
            global-note.md) _global_note_template_inline "${(@)@}" ;;
            investigation.md) _investigation_template_inline "${(@)@}" ;;
            *) echo "Unknown template: $tmpl_name" >&2; return 1 ;;
        esac
    fi
}

# Inline fallbacks (used when template files are missing)
_branch_note_template_inline() {
    local repo="" branch="" date="" machine=""
    for pair in "$@"; do
        case "${pair%%=*}" in
            REPO) repo="${pair#*=}" ;; BRANCH) branch="${pair#*=}" ;;
            DATE) date="${pair#*=}" ;; MACHINE) machine="${pair#*=}" ;;
        esac
    done
    cat << EOF
---
repo: $repo
branch: $branch
created: $date
status: active
machine: $machine
type:
work_item:
pr:
tags: []
collaborators: []
---

# $repo / $branch

## Goal


## Progress


## Todos
- [ ]

## Blockers
-

## Decisions
-

## To Research
-

## Collaboration
-

## To Ask
-

---
## Windows
EOF
}

_global_note_template_inline() {
    local repo="" date="" machine=""
    for pair in "$@"; do
        case "${pair%%=*}" in
            REPO) repo="${pair#*=}" ;; DATE) date="${pair#*=}" ;; MACHINE) machine="${pair#*=}" ;;
        esac
    done
    cat << EOF
---
repo: $repo
created: $date
status: active
machine: $machine
---

# $repo (global)

## Goal


## Todos
- [ ]

## Blockers
-

## Decisions
-

## To Research
-

## Collaboration
-

## To Ask
-
EOF
}

_investigation_template_inline() {
    local title="" date="" repo="" branch=""
    for pair in "$@"; do
        case "${pair%%=*}" in
            TITLE) title="${pair#*=}" ;; DATE) date="${pair#*=}" ;;
            REPO) repo="${pair#*=}" ;; BRANCH) branch="${pair#*=}" ;;
        esac
    done
    cat << EOF
# $title
<!-- Created: $date | Branch: $repo/$branch -->

## Summary


## Findings

EOF
}

# Create note from template if it doesn't exist
ensure_note() {
    local note_dir="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH"
    local note_file="$note_dir/note.md"
    if [[ ! -f "$note_file" ]]; then
        mkdir -p "$note_dir"
        _render_template branch-note.md \
            "REPO=$NOTE_REPO" "BRANCH=$NOTE_BRANCH" \
            "DATE=$(date +%Y-%m-%d)" "MACHINE=$_HOSTNAME" > "$note_file"
    fi
    ensure_scripts_dir "$NOTE_REPO"
}

# Create repo-level global note if it doesn't exist
ensure_global_note() {
    local note_file="$NOTES_DIR/$NOTE_REPO/note.md"
    if [[ ! -f "$note_file" ]]; then
        mkdir -p "$NOTES_DIR/$NOTE_REPO"
        _render_template global-note.md \
            "REPO=$NOTE_REPO" "DATE=$(date +%Y-%m-%d)" "MACHINE=$_HOSTNAME" > "$note_file"
    fi
}

# --- Helpers: Scripts ---

# Resolve path to a named script (always in main's note dir)
resolve_script() {
    REPLY="$NOTES_DIR/$1/main/scripts/$2"
}

# Ensure scripts/ dir exists; auto-migrate old build.sh on first access
ensure_scripts_dir() {
    local repo="$1"
    local scripts_dir="$NOTES_DIR/$repo/main/scripts"
    local old_build_sh="$NOTES_DIR/$repo/main/build.sh"

    mkdir -p "$scripts_dir"

    # Migrate old build.sh → scripts/build
    if [[ -f "$old_build_sh" ]]; then
        if grep -q "# bn-placeholder: no build configured" "$old_build_sh" 2>/dev/null; then
            rm "$old_build_sh"
        else
            mv "$old_build_sh" "$scripts_dir/build"
            echo "Migrated build.sh → scripts/build for $repo" >&2
        fi
    fi
}

# Run a named script if it exists, with cwd set to given directory
run_script() {
    local repo="$1" name="$2" work_dir="$3"
    local script
    resolve_script "$repo" "$name"; script=$REPLY
    if [[ -x "$script" ]]; then
        echo "Running scripts/$name for $repo..."
        (cd "$work_dir" && "$script")
        return $?
    fi
    return 0
}

# --- Helpers: Section Manipulation ---

# Map short section name to heading
section_heading() {
    case "$1" in
        todo|todos)         echo "## Todos" ;;
        blocker|blockers)   echo "## Blockers" ;;
        decision|decisions) echo "## Decisions" ;;
        research)           echo "## To Research" ;;
        collab)             echo "## Collaboration" ;;
        ask)                echo "## To Ask" ;;
        *) echo "" ;;
    esac
}

# Format line based on section type
format_line() {
    local section="$1" text="$2"
    case "$section" in
        todo|todos) echo "- [ ] $text" ;;
        *)          echo "- $text" ;;
    esac
}

# Insert a line into the correct section of a note
insert_into_section() {
    local note_file="$1" heading="$2" line="$3"

    local heading_line
    heading_line=$(grep -n "^${heading}$" "$note_file" | head -1 | cut -d: -f1)
    [[ -z "$heading_line" ]] && { echo "Section '$heading' not found in note" >&2; return 1; }

    local after_heading=$((heading_line + 1))
    local next_heading_rel
    next_heading_rel=$(tail -n +$after_heading "$note_file" | grep -n '^## \|^---$' | head -1 | cut -d: -f1)

    if [[ -n "$next_heading_rel" ]]; then
        local insert_at=$((heading_line + next_heading_rel - 1))
        # Insert blank line + content before the next heading
        perl -i -pe "print \"${line}\n\" if \$. == ${insert_at}" "$note_file"
    else
        echo "$line" >> "$note_file"
    fi
}

# Extract non-placeholder items from a named section of a note file.
# Todos:   skips bare "- [ ]" and "- [ ] test"
# Others:  skips bare "-" lines
# Prints one item per line; returns 1 if section is empty/missing.
_section_items() {
    local note_file="$1" heading="$2"
    local -a items
    # Capture lines between the heading and the next heading/frontmatter fence
    while IFS= read -r line; do
        [[ -n "$line" ]] && items+=("$line")
    done <<< "$(awk "/^${heading}\$/{found=1; next} /^## |^---\$/{found=0} found && /^- /" "$note_file" 2>/dev/null)"

    # Filter out placeholders
    local -a real
    for item in "${items[@]}"; do
        # Skip bare todo placeholder and bare bullet
        [[ "$item" =~ '^- \[ \]( test)?$' ]] && continue
        [[ "$item" == "-" ]] && continue
        real+=("$item")
    done

    (( ${#real[@]} == 0 )) && return 1
    for item in "${real[@]}"; do
        echo "  $item"
    done
}

# Remove placeholder lines from a note file:
#   todos:  bare "- [ ]" or "- [ ] test"
#   others: bare "-" lines
_clean_note() {
    local note_file="$1"
    local before after
    before=$(grep -cE '^- \[ \]( test)?$|^-$' "$note_file" 2>/dev/null || true)
    (( before == 0 )) && return 0
    sed -i -E '/^- \[ \]( test)?$/d; /^-$/d' "$note_file"
    after=$(grep -cE '^- \[ \]( test)?$|^-$' "$note_file" 2>/dev/null || true)
    echo "  Removed $(( before - after )) placeholder(s)"
}

# --- Helpers: Single-pass Note Parser ---

# Parse a note file in a single awk pass. Outputs key=value lines for frontmatter
# fields and section content prefixed by section tag.
# Usage: output=$(_parse_note "$note_file")
# Then: echo "$output" | grep '^status=' etc.
_parse_note() {
    local note_file="$1"
    awk '
    BEGIN {
        in_front = 0; front_count = 0
        section = ""
        todos = 0; open_todos = 0; blockers = 0; research = 0; asks = 0
        decisions = 0; collab = 0
    }
    /^---$/ {
        if (front_count == 0) { in_front = 1; front_count++; next }
        if (in_front) { in_front = 0; next }
    }
    in_front {
        # Extract frontmatter key: value
        if (match($0, /^([a-z_]+): *(.*)$/, m)) {
            print m[1] "=" m[2]
        }
        next
    }
    /^## Todos$/       { section = "TODO"; next }
    /^## Blockers$/    { section = "BLOCKER"; next }
    /^## To Research$/ { section = "RESEARCH"; next }
    /^## To Ask$/      { section = "ASK"; next }
    /^## Decisions$/   { section = "DECISION"; next }
    /^## Collaboration$/ { section = "COLLAB"; next }
    /^## / || /^---$/  { section = ""; next }

    section != "" && /^- / {
        line = $0
        # Skip placeholders: bare "- [ ]", "- [ ] test", bare "-"
        if (line == "- [ ]" || line == "- [ ] test" || line == "-") next

        if (section == "TODO") {
            todos++
            if (line ~ /^- \[ \] /) { open_todos++; print "OPEN_TODO:" line }
            else { print "TODO:" line }
        }
        else if (section == "BLOCKER")  { blockers++;  print "BLOCKER:" line }
        else if (section == "RESEARCH") { research++;  print "RESEARCH:" line }
        else if (section == "ASK")      { asks++;      print "ASK:" line }
        else if (section == "DECISION") { decisions++; print "DECISION:" line }
        else if (section == "COLLAB")   { collab++;    print "COLLAB:" line }
    }

    END {
        print "todos=" todos
        print "open_todos=" open_todos
        print "blockers=" blockers
        print "research=" research
        print "asks=" asks
        print "decisions=" decisions
        print "collab=" collab
    }
    ' "$note_file"
}

# Extract a value from _parse_note output: _pn_val "$output" "key"
# Pure zsh — no subprocesses.
_pn_val() {
    local match=${(M)${(f)1}:#${2}=*}
    echo "${match#${2}=}"
}

# Extract section lines from _parse_note output: _pn_lines "$output" "PREFIX"
# Pure zsh — no subprocesses.
_pn_lines() {
    local -a matches=("${(M@)${(f)1}:#${2}:*}")
    local line
    for line in "${matches[@]}"; do
        [[ -n "$line" ]] && echo "${line#${2}:}"
    done
}

# --- Helpers: Batch Note Parser ---

# Parse ALL note files in a single awk invocation. Each line is prefixed with
# the filename so we can split per-file afterwards.
# Usage: _ALL_PARSED=$(_parse_all_notes "${note_files[@]}")
#        local parsed=$(_pn_for_file "$_ALL_PARSED" "$note_file")
_parse_all_notes() {
    (( $# == 0 )) && return
    awk '
    BEGIN {
        in_front = 0; front_count = 0
        section = ""
        todos = 0; open_todos = 0; blockers = 0; research = 0; asks = 0
        decisions = 0; collab = 0
        cur_file = ""
    }
    FNR == 1 {
        # Emit counts for previous file
        if (cur_file != "") {
            print cur_file "|todos=" todos
            print cur_file "|open_todos=" open_todos
            print cur_file "|blockers=" blockers
            print cur_file "|research=" research
            print cur_file "|asks=" asks
            print cur_file "|decisions=" decisions
            print cur_file "|collab=" collab
        }
        cur_file = FILENAME
        in_front = 0; front_count = 0; section = ""
        todos = 0; open_todos = 0; blockers = 0; research = 0; asks = 0
        decisions = 0; collab = 0
    }
    /^---$/ {
        if (front_count == 0) { in_front = 1; front_count++; next }
        if (in_front) { in_front = 0; next }
    }
    in_front {
        if (match($0, /^([a-z_]+): *(.*)$/, m)) {
            print cur_file "|" m[1] "=" m[2]
        }
        next
    }
    /^## Todos$/       { section = "TODO"; next }
    /^## Blockers$/    { section = "BLOCKER"; next }
    /^## To Research$/ { section = "RESEARCH"; next }
    /^## To Ask$/      { section = "ASK"; next }
    /^## Decisions$/   { section = "DECISION"; next }
    /^## Collaboration$/ { section = "COLLAB"; next }
    /^## / || /^---$/  { section = ""; next }

    section != "" && /^- / {
        line = $0
        if (line == "- [ ]" || line == "- [ ] test" || line == "-") next
        if (section == "TODO") {
            todos++
            if (line ~ /^- \[ \] /) { open_todos++; print cur_file "|OPEN_TODO:" line }
            else { print cur_file "|TODO:" line }
        }
        else if (section == "BLOCKER")  { blockers++;  print cur_file "|BLOCKER:" line }
        else if (section == "RESEARCH") { research++;  print cur_file "|RESEARCH:" line }
        else if (section == "ASK")      { asks++;      print cur_file "|ASK:" line }
        else if (section == "DECISION") { decisions++; print cur_file "|DECISION:" line }
        else if (section == "COLLAB")   { collab++;    print cur_file "|COLLAB:" line }
    }

    END {
        if (cur_file != "") {
            print cur_file "|todos=" todos
            print cur_file "|open_todos=" open_todos
            print cur_file "|blockers=" blockers
            print cur_file "|research=" research
            print cur_file "|asks=" asks
            print cur_file "|decisions=" decisions
            print cur_file "|collab=" collab
        }
    }
    ' "$@"
}

# Extract lines for a specific file from batch output. Pure zsh.
_pn_for_file() {
    local all="$1" file="$2"
    local prefix="${file}|"
    local -a lines=("${(M@)${(f)all}:#${prefix}*}")
    local line
    for line in "${lines[@]}"; do
        [[ -n "$line" ]] && echo "${line#${prefix}}"
    done
}

# --- Commands ---

cmd_path() {
    require_git_context
    echo "$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH"
}

cmd_cat() {
    require_git_context
    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    # Auto-prune: if note is active, repo is bare-based, and worktree is gone
    if [[ -f "$note_file" && -d "$BARE_DIR/${NOTE_REPO}.git" ]]; then
        local wt_path="$WORKTREE_DIR/${NOTE_REPO}/${NOTE_BRANCH}"
        if [[ ! -d "$wt_path" ]] && [[ "$(get_note_status "$note_file")" == "active" ]]; then
            set_note_status "$note_file" "closed"
            echo "Auto-closed: $NOTE_REPO/$NOTE_BRANCH (worktree removed)" >&2
        fi
    fi
    # Auto-discover PR link if empty and gh is available
    if [[ -f "$note_file" ]]; then
        _frontmatter_val "$note_file" "pr"
        if [[ -z "$REPLY" ]] && command -v gh &>/dev/null; then
            local auto_pr
            auto_pr=$(gh pr view --json url -q .url 2>/dev/null)
            if [[ -n "$auto_pr" ]]; then
                _set_frontmatter "$note_file" "pr" "$auto_pr"
                echo "Auto-linked PR: $auto_pr" >&2
            fi
        fi
    fi

    local file="${1:-note.md}"
    cat "$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/$file"

    # Append footer with investigation files and scripts (only for default note.md)
    if [[ "$file" == "note.md" ]]; then
        local note_dir="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH"
        local scripts_dir="$NOTES_DIR/$NOTE_REPO/main/scripts"

        # Investigation files: .md files excluding note.md, skip scripts/ subdir
        local -a inv_files
        for f in "$note_dir"/*.md(N); do
            [[ "${f:t}" == "note.md" ]] && continue
            inv_files+=("$f")
        done

        if (( ${#inv_files[@]} > 0 )); then
            echo ""
            echo "--- Files ---"
            for f in "${inv_files[@]}"; do
                local lines
                lines=$(wc -l < "$f" | tr -d ' ')
                echo "  ${f:t} ($lines lines)"
            done
        fi

        # Scripts from main's scripts dir
        local -a scripts
        for f in "$scripts_dir"/*(Nx); do
            scripts+=("${f:t}")
        done

        if (( ${#scripts[@]} > 0 )); then
            echo ""
            echo "--- Scripts ---"
            for s in "${scripts[@]}"; do
                echo "  $s"
            done
        fi
    fi
}

cmd_edit() {
    require_git_context
    ensure_note
    local file="${1:-note.md}"
    ${EDITOR:-nvim} "$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/$file"
}

cmd_files() {
    require_git_context
    local note_dir="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH"
    local subcmd="${1:-}"

    case "$subcmd" in
        new)
            local name="$2"
            [[ -z "$name" ]] && { echo "Usage: bn files new <name>" >&2; exit 1; }
            [[ "$name" != *.md ]] && name="${name}.md"
            local filepath="$note_dir/$name"
            if [[ -f "$filepath" ]]; then
                echo "File already exists: $filepath" >&2
                exit 1
            fi
            ensure_note
            local title="${name%.md}"
            _render_template investigation.md \
                "TITLE=$title" "DATE=$(date +%Y-%m-%d)" \
                "REPO=$NOTE_REPO" "BRANCH=$NOTE_BRANCH" > "$filepath"
            echo "Created: $filepath"
            ;;
        edit)
            local name="$2"
            [[ -z "$name" ]] && { echo "Usage: bn files edit <name>" >&2; exit 1; }
            [[ "$name" != *.md ]] && name="${name}.md"
            local filepath="$note_dir/$name"
            [[ ! -f "$filepath" ]] && { echo "File not found: $name" >&2; exit 1; }
            ${EDITOR:-nvim} "$filepath"
            ;;
        "")
            # List investigation files
            local -a inv_files
            for f in "$note_dir"/*.md(N); do
                [[ "${f:t}" == "note.md" ]] && continue
                inv_files+=("$f")
            done
            if (( ${#inv_files[@]} == 0 )); then
                echo "No investigation files in $NOTE_REPO/$NOTE_BRANCH"
                echo "Create one with: bn files new <name>"
                return
            fi
            echo "Investigation files ($NOTE_REPO/$NOTE_BRANCH):"
            for f in "${inv_files[@]}"; do
                local lines
                lines=$(wc -l < "$f" | tr -d ' ')
                echo "  ${f:t} ($lines lines)"
            done
            ;;
        *)
            # View a specific file
            local name="$subcmd"
            [[ "$name" != *.md ]] && name="${name}.md"
            local filepath="$note_dir/$name"
            [[ ! -f "$filepath" ]] && { echo "File not found: $name" >&2; exit 1; }
            cat "$filepath"
            ;;
    esac
}

cmd_default() {
    require_git_context
    ensure_note
    echo "$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH"
}

# Add a line to a section
cmd_add() {
    local section="$1"
    [[ -z "$section" ]] && { echo "Usage: branch-note add <section> <text>" >&2; exit 1; }
    shift
    local text="$*"
    [[ -z "$text" ]] && { echo "Usage: branch-note add <section> <text>" >&2; exit 1; }

    local heading
    heading=$(section_heading "$section")
    [[ -z "$heading" ]] && { echo "Unknown section: $section (use: todo, blocker, decision, research, collab, ask)" >&2; exit 1; }

    require_git_context
    ensure_note

    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    local line
    line=$(format_line "$section" "$text")

    insert_into_section "$note_file" "$heading" "$line"
    echo "Added to ${heading#\#\# }: $text"
}

# List notes across repos (active + local machine by default)
cmd_list() {
    local show_all=false
    local all_machines=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all) show_all=true; shift ;;
            --all-machines) all_machines=true; shift ;;
            *) shift ;;
        esac
    done

    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local -a note_files=("$NOTES_DIR"/*/*/note.md(N))
    (( ${#note_files[@]} == 0 )) && { echo "No branch notes found"; exit 0; }
    local _ALL_PARSED=$(_parse_all_notes "${note_files[@]}")

    local found=false
    for note_file in "${note_files[@]}"; do
        local parsed=$(_pn_for_file "$_ALL_PARSED" "$note_file")
        local note_status=$(_pn_val "$parsed" "status")
        [[ -z "$note_status" ]] && note_status="active"

        if ! $show_all && [[ "$note_status" == "closed" ]]; then
            continue
        fi

        local machine=$(_pn_val "$parsed" "machine")
        if ! $all_machines && [[ -n "$machine" && "$machine" != "$_HOSTNAME" ]]; then
            continue
        fi

        found=true
        local note_dir=${note_file:h}
        local branch=${note_dir:t}
        local repo=${note_dir:h:t}

        local type=$(_pn_val "$parsed" "type")
        [[ -z "$type" ]] && type="-"

        local todos=$(_pn_val "$parsed" "open_todos")
        local blockers=$(_pn_val "$parsed" "blockers")
        local created=$(_pn_val "$parsed" "created")

        local note_status_tag=""
        [[ "$note_status" == "closed" ]] && note_status_tag=" (closed)"

        local machine_tag=""
        [[ -n "$machine" ]] && machine_tag=" [$machine]"

        local counts="${todos} todos"
        (( blockers > 0 )) && counts="$counts, $blockers blockers"

        printf "%-30s %-12s %s  %s%s%s\n" "$repo/$branch" "$type" "$counts" "$created" "$note_status_tag" "$machine_tag"
    done

    $found || echo "No branch notes found"
}

# Close current branch's note
cmd_close() {
    require_git_context
    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    [[ ! -f "$note_file" ]] && { echo "No note for $NOTE_REPO/$NOTE_BRANCH" >&2; exit 1; }

    set_note_status "$note_file" "closed"
    echo "Closed note: $NOTE_REPO/$NOTE_BRANCH"
}

# Close notes whose worktrees no longer exist
cmd_prune() {
    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local closed=0
    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        local note_status=$(get_note_status "$note_file")
        [[ "$note_status" == "closed" ]] && continue

        local note_dir=${note_file:h}
        local branch=${note_dir:t}
        local repo=${note_dir:h:t}

        # Only prune worktree-based repos (those with a bare repo)
        [[ ! -d "$BARE_DIR/${repo}.git" ]] && continue

        local worktree_path="$WORKTREE_DIR/${repo}/${branch}"
        if [[ ! -d "$worktree_path" ]]; then
            set_note_status "$note_file" "closed"
            echo "Closed: $repo/$branch (worktree removed)"
            closed=$((closed + 1))
        fi
    done

    (( closed == 0 )) && echo "Nothing to prune"

    # Auto-archive old closed notes
    cmd_archive
}

# Summary dashboard
cmd_summary() {
    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local total_todos=0
    local total_blockers=0
    local total_research=0
    local total_asks=0
    local details=""
    local found=false

    local -a note_files=("$NOTES_DIR"/*/*/note.md(N))
    (( ${#note_files[@]} == 0 )) && { echo "No branch notes found"; exit 0; }
    local _ALL_PARSED=$(_parse_all_notes "${note_files[@]}")

    for note_file in "${note_files[@]}"; do
        local parsed=$(_pn_for_file "$_ALL_PARSED" "$note_file")
        local note_status=$(_pn_val "$parsed" "status")
        [[ -z "$note_status" ]] && note_status="active"
        [[ "$note_status" == "closed" ]] && continue

        local machine=$(_pn_val "$parsed" "machine")
        [[ -n "$machine" && "$machine" != "$_HOSTNAME" ]] && continue

        found=true
        local note_dir=${note_file:h}
        local branch=${note_dir:t}
        local repo=${note_dir:h:t}

        local type=$(_pn_val "$parsed" "type")
        [[ -z "$type" ]] && type="-"

        local todos=$(_pn_val "$parsed" "open_todos")
        local blockers=$(_pn_val "$parsed" "blockers")
        local research=$(_pn_val "$parsed" "research")
        local asks=$(_pn_val "$parsed" "asks")

        total_todos=$((total_todos + todos))
        total_blockers=$((total_blockers + blockers))
        total_research=$((total_research + research))
        total_asks=$((total_asks + asks))

        # Build per-branch detail
        local header="\n$repo/$branch ($type, $todos todos"
        (( blockers > 0 )) && header="$header, $blockers blockers"
        (( research > 0 )) && header="$header, $research research"
        (( asks > 0 )) && header="$header, $asks asks"
        header="$header)"

        local items=""
        # Collect open todos from parsed output
        while IFS= read -r line; do
            [[ -n "$line" ]] && items="$items\n  ${line#- }"
        done <<< "$(_pn_lines "$parsed" "OPEN_TODO")"

        # Collect blockers from parsed output
        while IFS= read -r line; do
            [[ -n "$line" ]] && items="$items\n  [!] ${line#- }"
        done <<< "$(_pn_lines "$parsed" "BLOCKER")"

        if (( todos > 0 )) || (( blockers > 0 )); then
            details="$details$header$items"
        fi
    done

    if $found; then
        echo "Open todos across all branches: $total_todos"
        echo "Blockers: $total_blockers"
        (( total_research > 0 )) && echo "To Research: $total_research"
        (( total_asks > 0 )) && echo "To Ask: $total_asks"
        [[ -n "$details" ]] && print "$details"
    else
        echo "No branch notes found"
    fi
}

# Refresh current branch: fetch, pull, build
cmd_refresh() {
    require_git_context

    local worktree_path
    worktree_path=$(pwd)
    local bare_repo="$BARE_DIR/${NOTE_REPO}.git"

    echo "Fetching origin for $NOTE_REPO..."
    if [[ -d "$bare_repo" ]]; then
        git --git-dir="$bare_repo" fetch origin
    else
        git -C "$worktree_path" fetch origin
    fi

    echo "Pulling $NOTE_BRANCH (ff-only)..."
    git -C "$worktree_path" pull --ff-only

    run_script "$NOTE_REPO" "build" "$worktree_path"
    echo "Refresh complete: $NOTE_REPO/$NOTE_BRANCH"
}

# Refresh all main worktrees: parallel fetch (batched), sequential update+build
cmd_refresh_all() {
    local bare_repos=("$BARE_DIR"/*.git(N/))
    [[ ${#bare_repos[@]} -eq 0 ]] && { echo "No bare repos found"; exit 0; }

    local updated=0 skipped=0 failed=0
    local batch_size=4

    # Phase 1: batched parallel fetch (avoid SSH rate limits)
    echo -e "${BLUE}Fetching ${#bare_repos[@]} repos (batch size $batch_size)...${NC}"
    local count=0
    local pids=()
    for bare in "${bare_repos[@]}"; do
        git --git-dir="$bare" fetch origin 2>/dev/null &
        pids+=($!)
        count=$((count + 1))
        if (( count % batch_size == 0 )); then
            for pid in "${pids[@]}"; do wait "$pid" 2>/dev/null; done
            pids=()
        fi
    done
    # Wait for remaining
    for pid in "${pids[@]}"; do wait "$pid" 2>/dev/null; done
    echo -e "${GREEN}Fetch complete.${NC}"

    # Phase 2: sequential update + build
    for bare in "${bare_repos[@]}"; do
        local repo_name=${${bare:t}%.git}
        local main_wt="$WORKTREE_DIR/${repo_name}/main"

        if [[ ! -d "$main_wt" ]]; then
            echo -e "  ${YELLOW}${repo_name}: no main worktree, skipping${NC}"
            skipped=$((skipped + 1))
            continue
        fi

        echo -e "  ${BLUE}${repo_name}: updating main...${NC}"

        if git -C "$main_wt" merge --ff-only origin/main 2>/dev/null; then
            if run_script "$repo_name" "build" "$main_wt"; then
                echo -e "  ${GREEN}${repo_name}: updated${NC}"
                updated=$((updated + 1))
            else
                echo -e "  ${RED}${repo_name}: build failed${NC}"
                failed=$((failed + 1))
            fi
        else
            echo -e "  ${RED}${repo_name}: pull failed (not fast-forwardable?)${NC}"
            failed=$((failed + 1))
        fi
    done

    echo ""
    echo -e "Summary: ${GREEN}$updated updated${NC}, ${YELLOW}$skipped skipped${NC}, ${RED}$failed failed${NC}"
}

# Print main note dir path + list available scripts
cmd_main() {
    require_git_context
    ensure_scripts_dir "$NOTE_REPO"
    local main_dir="$NOTES_DIR/$NOTE_REPO/main"
    echo "$main_dir"

    local scripts_dir="$main_dir/scripts"
    local -a scripts
    for f in "$scripts_dir"/*(Nx); do
        scripts+=("$(basename "$f")")
    done
    if (( ${#scripts[@]} > 0 )); then
        echo ""
        echo "Scripts:"
        for s in "${scripts[@]}"; do
            echo "  $s"
        done
    else
        echo ""
        echo "No scripts yet. Create one with: bn script new <name>"
    fi
}

# Run a named script (default: build)
cmd_build() {
    local name="${1:-build}"
    require_git_context
    ensure_scripts_dir "$NOTE_REPO"

    local script
    resolve_script "$NOTE_REPO" "$name"; script=$REPLY
    if [[ ! -f "$script" ]]; then
        echo "No script '$name' for $NOTE_REPO" >&2
        echo "Create one with: bn script new $name" >&2
        exit 1
    fi
    if [[ ! -x "$script" ]]; then
        chmod +x "$script"
    fi

    local work_dir
    work_dir=$(pwd)
    echo "Running scripts/$name for $NOTE_REPO..."
    (cd "$work_dir" && "$script")
}

# Script management: new, edit, list
cmd_script() {
    local subcmd="${1:-}"
    shift 2>/dev/null || true

    case "$subcmd" in
        new)
            local name="$1"
            [[ -z "$name" ]] && { echo "Usage: bn script new <name>" >&2; exit 1; }
            require_git_context
            ensure_scripts_dir "$NOTE_REPO"

            local script
            resolve_script "$NOTE_REPO" "$name"; script=$REPLY
            if [[ -f "$script" ]]; then
                echo "Script '$name' already exists: $script" >&2
                echo "Use 'bn script edit $name' to modify it." >&2
                exit 1
            fi

            cat > "$script" << SCRIPTEOF
#!/usr/bin/env zsh
set -e

# $name script for $NOTE_REPO
# Runs with cwd set to the repo/worktree directory.

SCRIPTEOF
            chmod +x "$script"
            echo "Created: $script"
            echo "Edit with: bn script edit $name"
            ;;
        edit)
            local name="$1"
            [[ -z "$name" ]] && { echo "Usage: bn script edit <name>" >&2; exit 1; }
            require_git_context
            ensure_scripts_dir "$NOTE_REPO"

            local script
            resolve_script "$NOTE_REPO" "$name"; script=$REPLY
            if [[ ! -f "$script" ]]; then
                echo "No script '$name' for $NOTE_REPO. Create one with: bn script new $name" >&2
                exit 1
            fi
            ${EDITOR:-nvim} "$script"
            ;;
        list|l|"")
            require_git_context
            ensure_scripts_dir "$NOTE_REPO"

            local scripts_dir="$NOTES_DIR/$NOTE_REPO/main/scripts"
            local -a scripts
            for f in "$scripts_dir"/*(Nx); do
                scripts+=("${f:t}")
            done
            if (( ${#scripts[@]} > 0 )); then
                echo "Scripts for $NOTE_REPO:"
                for s in "${scripts[@]}"; do
                    echo "  $s"
                done
            else
                echo "No scripts for $NOTE_REPO"
                echo "Create one with: bn script new <name>"
            fi
            ;;
        *)
            echo "Usage: bn script [new <name>|edit <name>|list]" >&2
            exit 1
            ;;
    esac
}

# Status: one-line summary for current branch
cmd_status() {
    require_git_context
    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    if [[ ! -f "$note_file" ]]; then
        echo "$NOTE_REPO/$NOTE_BRANCH: no note"
        return
    fi

    local todos=0 blockers=0
    todos=$(grep -c '^\- \[ \]' "$note_file" 2>/dev/null || true)
    blockers=$(awk '/^## Blockers$/{found=1; next} /^## |^---$/{found=0} found && /^- ./' "$note_file" | wc -l | tr -d ' ')

    local parts=()
    (( todos > 0 )) && parts+=("${todos} todo$( (( todos != 1 )) && echo s)")
    (( blockers > 0 )) && parts+=("${blockers} blocker$( (( blockers != 1 )) && echo s)")
    if [[ ${#parts[@]} -eq 0 ]]; then
        echo "$NOTE_REPO/$NOTE_BRANCH: clear"
    else
        echo "$NOTE_REPO/$NOTE_BRANCH: ${(j:, :)parts}"
    fi
}

# Todo: list open todos across all active branches
cmd_todo() {
    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local -a note_files=("$NOTES_DIR"/*/*/note.md(N))
    (( ${#note_files[@]} == 0 )) && { echo "No branch notes found"; exit 0; }
    local _ALL_PARSED=$(_parse_all_notes "${note_files[@]}")

    local found=false
    for note_file in "${note_files[@]}"; do
        local parsed=$(_pn_for_file "$_ALL_PARSED" "$note_file")
        local note_status=$(_pn_val "$parsed" "status")
        [[ -z "$note_status" ]] && note_status="active"
        [[ "$note_status" == "closed" ]] && continue

        local machine=$(_pn_val "$parsed" "machine")
        [[ -n "$machine" && "$machine" != "$_HOSTNAME" ]] && continue

        local open_todos=$(_pn_val "$parsed" "open_todos")
        (( open_todos == 0 )) && continue

        found=true
        local note_dir=${note_file:h}
        local branch=${note_dir:t}
        local repo=${note_dir:h:t}

        echo -e "${BLUE}${repo}/${branch}${NC}"
        while IFS= read -r line; do
            [[ -n "$line" ]] && echo "  $line"
        done <<< "$(_pn_lines "$parsed" "OPEN_TODO")"
    done

    $found || echo "No open todos"
}

# Archive closed notes older than N days
cmd_archive() {
    local days=30
    local dry_run=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --days) days="$2"; shift 2 ;;
            --dry-run) dry_run=true; shift ;;
            *) echo "Unknown option: $1" >&2; exit 1 ;;
        esac
    done

    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local cutoff
    cutoff=$(date -v-${days}d '+%Y-%m-%d')

    local archived=0
    local -a affected_paths=()

    if $dry_run; then
        echo -e "${YELLOW}[DRY RUN — no changes will be made]${NC}"
        echo ""
    fi

    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        local note_status=$(get_note_status "$note_file")
        [[ "$note_status" != "closed" ]] && continue

        local created=$(sed -n '/^---$/,/^---$/{ /^created:/s/^created: *//p; }' "$note_file")
        [[ -z "$created" ]] && continue
        [[ "$created" > "$cutoff" ]] && continue

        local note_dir=${note_file:h}
        local branch=${note_dir:t}
        local repo=${note_dir:h:t}

        local dest="$NOTES_DIR/archive/$repo/$branch"

        if [[ -d "$dest" ]]; then
            echo -e "${RED}Already exists, skipping: archive/$repo/$branch${NC}" >&2
            continue
        fi

        echo -e "${YELLOW}Archive: $repo/$branch${NC} (created $created)"

        if ! $dry_run; then
            mkdir -p "${dest:h}"
            mv "$note_dir" "$dest"
            archived=$((archived + 1))
            affected_paths+=("$repo/$branch")

            # Clean up empty repo dir
            local repo_dir="$NOTES_DIR/$repo"
            if [[ -d "$repo_dir" ]] && [[ -z "$(ls -A "$repo_dir")" ]]; then
                rmdir "$repo_dir"
            fi
        else
            archived=$((archived + 1))
        fi
    done

    echo ""
    if $dry_run; then
        echo -e "${GREEN}Would archive: $archived note(s)${NC}"
    else
        echo -e "${GREEN}Archived: $archived note(s)${NC}"

        # Auto-commit only the moved note directories
        if (( archived > 0 )); then
            for p in "${affected_paths[@]}"; do
                git -C "$NOTES_DIR" add -- "archive/$p"
                git -C "$NOTES_DIR" rm -r --cached --ignore-unmatch --quiet -- "$p"
            done
            git -C "$NOTES_DIR" diff --cached --quiet || {
                git -C "$NOTES_DIR" commit -m "archive ${archived} note(s)" >/dev/null
                echo -e "${GREEN}Committed to personal-notes${NC}"
            }
        fi
    fi
}

# Strip placeholder lines from notes
cmd_clean() {
    local all=false
    [[ "${1:-}" == "--all" ]] && all=true

    if $all; then
        [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }
        local cleaned=0 note_status note_dir branch repo count
        for note_file in "$NOTES_DIR"/*/*/note.md(N); do
            note_status=$(get_note_status "$note_file")
            [[ "$note_status" == "closed" ]] && continue
            note_dir=${note_file:h}
            branch=${note_dir:t}
            repo=${note_dir:h:t}
            count=$(grep -cE '^- \[ \]( test)?$|^-$' "$note_file" 2>/dev/null || true)
            (( count == 0 )) && continue
            echo "${repo}/${branch}:"
            _clean_note "$note_file"
            cleaned=$(( cleaned + count ))
        done
        (( cleaned == 0 )) && echo "No placeholders found" || print "\nTotal removed: $cleaned"
    else
        require_git_context
        local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md" count
        [[ ! -f "$note_file" ]] && { echo "No note for $NOTE_REPO/$NOTE_BRANCH" >&2; exit 1; }
        count=$(grep -cE '^- \[ \]( test)?$|^-$' "$note_file" 2>/dev/null || true)
        if (( count == 0 )); then
            echo "No placeholders in $NOTE_REPO/$NOTE_BRANCH"
        else
            echo "$NOTE_REPO/$NOTE_BRANCH:"
            _clean_note "$note_file"
        fi
    fi
}

# All active worktrees with todos, blockers, research, decisions, and questions
cmd_worktrees() {
    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local -a note_files=("$NOTES_DIR"/*/*/note.md(N))
    (( ${#note_files[@]} == 0 )) && { echo "No branch notes found"; exit 0; }
    local _ALL_PARSED=$(_parse_all_notes "${note_files[@]}")

    local found=false total_todos=0
    local note_dir branch repo created type meta
    local parsed note_status machine
    local todo_count blockers_count research_count decisions_count asks_count

    for note_file in "${note_files[@]}"; do
        parsed=$(_pn_for_file "$_ALL_PARSED" "$note_file")
        note_status=$(_pn_val "$parsed" "status")
        [[ -z "$note_status" ]] && note_status="active"
        [[ "$note_status" == "closed" ]] && continue

        machine=$(_pn_val "$parsed" "machine")
        [[ -n "$machine" && "$machine" != "$_HOSTNAME" ]] && continue

        found=true
        note_dir=${note_file:h}
        branch=${note_dir:t}
        repo=${note_dir:h:t}
        created=$(_pn_val "$parsed" "created")
        type=$(_pn_val "$parsed" "type")

        todo_count=$(_pn_val "$parsed" "todos")
        total_todos=$(( total_todos + $(_pn_val "$parsed" "open_todos") ))

        local pr=$(_pn_val "$parsed" "pr")

        meta="${created}"
        [[ -n "$type" ]] && meta="${meta}  ${type}"
        [[ -n "$pr" ]] && meta="${meta}  ${GREEN}PR${NC} $pr"
        echo -e "${BLUE}${repo}/${branch}${NC}  ${meta}"

        # Todos (both open and completed, from _parse_note)
        local open_todos=$(_pn_val "$parsed" "open_todos")
        if (( open_todos > 0 )); then
            echo -e "  ${YELLOW}Todos${NC}"
            while IFS= read -r line; do
                [[ -n "$line" ]] && echo "  $line"
            done <<< "$(_pn_lines "$parsed" "OPEN_TODO")"
        fi

        blockers_count=$(_pn_val "$parsed" "blockers")
        if (( blockers_count > 0 )); then
            echo -e "  ${RED}Blockers${NC}"
            while IFS= read -r line; do
                [[ -n "$line" ]] && echo "  $line"
            done <<< "$(_pn_lines "$parsed" "BLOCKER")"
        fi

        research_count=$(_pn_val "$parsed" "research")
        if (( research_count > 0 )); then
            echo -e "  ${GREEN}Research${NC}"
            while IFS= read -r line; do
                [[ -n "$line" ]] && echo "  $line"
            done <<< "$(_pn_lines "$parsed" "RESEARCH")"
        fi

        decisions_count=$(_pn_val "$parsed" "decisions")
        if (( decisions_count > 0 )); then
            echo -e "  ${YELLOW}Decisions${NC}"
            while IFS= read -r line; do
                [[ -n "$line" ]] && echo "  $line"
            done <<< "$(_pn_lines "$parsed" "DECISION")"
        fi

        asks_count=$(_pn_val "$parsed" "asks")
        if (( asks_count > 0 )); then
            echo -e "  ${NC}To Ask${NC}"
            while IFS= read -r line; do
                [[ -n "$line" ]] && echo "  $line"
            done <<< "$(_pn_lines "$parsed" "ASK")"
        fi
        echo ""
    done

    if $found; then
        echo -e "${GREEN}Total open todos: ${total_todos}${NC}"
    else
        echo "No active branch notes found"
    fi
}

# Repo-level global note (not branch-specific)
cmd_global() {
    require_git_context
    local subcmd="${1:-}"
    shift 2>/dev/null || true

    case "$subcmd" in
        --cat|"")
            ensure_global_note
            cat "$NOTES_DIR/$NOTE_REPO/note.md"
            ;;
        --edit)
            ensure_global_note
            ${EDITOR:-nvim} "$NOTES_DIR/$NOTE_REPO/note.md"
            ;;
        --path)
            echo "$NOTES_DIR/$NOTE_REPO"
            ;;
        add)
            local section="$1"; shift
            local text="$*"
            [[ -z "$section" || -z "$text" ]] && { echo "Usage: bn global add <section> <text>" >&2; exit 1; }
            local heading
            heading=$(section_heading "$section")
            [[ -z "$heading" ]] && { echo "Unknown section: $section" >&2; exit 1; }
            ensure_global_note
            local note_file="$NOTES_DIR/$NOTE_REPO/note.md"
            local line
            line=$(format_line "$section" "$text")
            insert_into_section "$note_file" "$heading" "$line"
            echo "Added to ${heading#\#\# } (global/$NOTE_REPO): $text"
            ;;
        *)
            echo "Usage: bn global [--cat|--edit|--path|add <section> <text>]" >&2
            exit 1
            ;;
    esac
}

# PR link management: store, open, or show PR URL
cmd_pr() {
    require_git_context
    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    local action="open"
    local url=""

    # Parse args
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --copy|-c) action="copy"; shift ;;
            --show|-s) action="show"; shift ;;
            *) url="$1"; shift ;;
        esac
    done

    if [[ -n "$url" ]]; then
        # Setting a PR link
        ensure_note
        _set_frontmatter "$note_file" "pr" "$url"
        echo "PR linked: $url"
        return
    fi

    # No URL arg: resolve from note or gh
    if [[ ! -f "$note_file" ]]; then
        echo "No note for $NOTE_REPO/$NOTE_BRANCH" >&2
        exit 1
    fi

    _frontmatter_val "$note_file" "pr"
    local pr_url="$REPLY"

    if [[ -z "$pr_url" ]]; then
        # No PR stored — try to find one via gh
        if command -v gh &>/dev/null; then
            pr_url=$(gh pr view --json url -q .url 2>/dev/null)
        fi
        if [[ -z "$pr_url" ]]; then
            echo "No PR linked for $NOTE_REPO/$NOTE_BRANCH"
            echo "Usage: bn pr <url>"
            return 1
        fi
        # Auto-save the discovered PR
        _set_frontmatter "$note_file" "pr" "$pr_url"
        echo "Auto-linked: $pr_url"
    fi

    case "$action" in
        copy)
            _copy_to_clipboard "$pr_url" && echo "Copied: $pr_url"
            ;;
        show)
            echo "$pr_url"
            ;;
        open)
            _open_url "$pr_url"
            echo "Opened: $pr_url"
            ;;
    esac
}

# Work item link management
cmd_link() {
    require_git_context
    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    local action="open"
    local id=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --copy|-c) action="copy"; shift ;;
            --show|-s) action="show"; shift ;;
            *) id="$1"; shift ;;
        esac
    done

    if [[ -n "$id" ]]; then
        ensure_note
        _set_frontmatter "$note_file" "work_item" "$id"
        echo "Work item linked: $id"
        return
    fi

    # Read existing work_item
    if [[ ! -f "$note_file" ]]; then
        echo "No note for $NOTE_REPO/$NOTE_BRANCH" >&2
        exit 1
    fi

    _frontmatter_val "$note_file" "work_item"
    local wi="$REPLY"

    if [[ -z "$wi" ]]; then
        echo "No work item linked for $NOTE_REPO/$NOTE_BRANCH"
        echo "Usage: bn link <id>"
        return 1
    fi

    # Build URL (Azure DevOps)
    local wi_url="https://dev.azure.com/office/Office/_workitems/edit/${wi}"

    case "$action" in
        copy) _copy_to_clipboard "$wi_url" && echo "Copied: $wi_url" ;;
        show) echo "$wi_url" ;;
        open) _open_url "$wi_url" && echo "Opened: $wi_url" || echo "$wi_url" ;;
    esac
}

# Show git diff stat alongside open todos
cmd_diff() {
    require_git_context
    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"

    echo -e "${BLUE}Changes ($NOTE_REPO/$NOTE_BRANCH vs main)${NC}"
    local diff_stat
    diff_stat=$(git diff --stat origin/main..HEAD 2>/dev/null)
    if [[ -z "$diff_stat" ]]; then
        echo "  (no changes vs main)"
    else
        echo "$diff_stat" | sed 's/^/  /'
    fi

    if [[ -f "$note_file" ]]; then
        local parsed=$(_parse_note "$note_file")
        local open_todos=$(_pn_val "$parsed" "open_todos")
        if (( open_todos > 0 )); then
            echo ""
            echo -e "${YELLOW}Open todos${NC}"
            while IFS= read -r line; do
                [[ -n "$line" ]] && echo "  $line"
            done <<< "$(_pn_lines "$parsed" "OPEN_TODO")"
        fi

        local blockers=$(_pn_val "$parsed" "blockers")
        if (( blockers > 0 )); then
            echo ""
            echo -e "${RED}Blockers${NC}"
            while IFS= read -r line; do
                [[ -n "$line" ]] && echo "  $line"
            done <<< "$(_pn_lines "$parsed" "BLOCKER")"
        fi
    fi

    echo ""
    local commits
    commits=$(git rev-list --count origin/main..HEAD 2>/dev/null || echo 0)
    echo -e "${GREEN}${commits} commit(s) ahead of main${NC}"
}

cmd_help() {
    cat << 'HELPEOF'
Usage: bn [command]

Commands:
  (none)                          Ensure note exists, print dir path
  --path, -p                      Print note dir path (no create)
  --cat, -c [file]                Print note.md (or specific file)
  --edit, -e [file]               Open note in $EDITOR
  add, a <section> <text>         Add line to section
  list, l [--all] [--all-machines] List active notes
  active                          List active notes (same as list)
  close                           Close current branch's note
  prune                           Close notes whose worktrees are gone
  summary, s                      Dashboard of active work
  status, st                      One-line status for current branch
  todo, t                         List open todos across all branches
  refresh, r                      Fetch, pull, build current branch
  refresh-all, ra                 Refresh all main worktrees
  main, m                         Print main note dir + list scripts
  build, b [name]                 Run a script (default: build)
  script, sc [new|edit|list]      Manage repo scripts
  files, f                        List investigation files in current branch
  files <name>                    Print contents of investigation file
  files new <name>                Create new investigation file
  files edit <name>               Open investigation file in $EDITOR
  archive [--days N] [--dry-run]  Archive closed notes older than N days (default 30)
  clean [--all]                   Remove empty placeholder todos
  worktrees, w                    All active worktrees with full todo lists
  pr [url]                        Link PR url, or open linked PR in browser
  pr --copy                       Copy PR url to clipboard
  pr --show                       Print PR url without opening
  link, wi [id]                   Link work item ID, or open linked work item
  link --copy                     Copy work item url to clipboard
  diff, d                         Git diff stat vs main + open todos
  global, g [--cat|--edit|--path] Repo-level global note (not branch-specific)
  global add <section> <text>     Add to repo global note

Scripts:
  Scripts live in <notes>/<repo>/main/scripts/ and run with cwd = repo dir.
  Use 'bn script new <name>' to create, 'bn script edit <name>' to modify.

Filtering:
  By default, list/summary/todo/worktrees only show notes for this machine.
  Notes without a machine field are always shown.
  Use --all-machines with list to see notes from all hosts.

Sections: todo, blocker, decision, research, collab, ask
HELPEOF
}

# --- Dispatch ---

case "${1:-}" in
    --path|-p)          cmd_path ;;
    --cat|-c)           shift; cmd_cat "$@" ;;
    --edit|-e)          shift; cmd_edit "$@" ;;
    add|a)              shift; cmd_add "$@" ;;
    list|l)             shift; cmd_list "$@" ;;
    active)             cmd_list ;;
    close)              cmd_close ;;
    prune)              cmd_prune ;;
    summary|s)          cmd_summary ;;
    status|st)          cmd_status ;;
    todo|todos|t)       cmd_todo ;;
    refresh|r)          cmd_refresh ;;
    refresh-all|ra)     cmd_refresh_all ;;
    main|m)             cmd_main ;;
    build|b)            shift; cmd_build "$@" ;;
    script|sc)          shift; cmd_script "$@" ;;
    archive)            shift; cmd_archive "$@" ;;
    clean)              shift; cmd_clean "$@" ;;
    files|f)            shift; cmd_files "$@" ;;
    worktrees|w)        cmd_worktrees ;;
    pr)                 shift; cmd_pr "$@" ;;
    link|wi)            shift; cmd_link "$@" ;;
    diff|d)             cmd_diff ;;
    global|g)           shift; cmd_global "$@" ;;
    -h|--help|help)     cmd_help ;;
    "")                 cmd_default ;;
    *)                  echo "Unknown command: $1" >&2; exit 1 ;;
esac
