#!/usr/bin/env zsh
# bn - Universal branch note resolver
# Usage:
#   bn                             # Ensure note exists, print dir path
#   bn --path|-p                    # Print note dir path only (no create)
#   bn --cat|-c [file]              # Print note.md contents (or specific file)
#   bn --edit|-e [file]             # Open note.md in $EDITOR (or specific file)
#   bn add|a <section> <text>       # Add line to section
#   bn list|l [--all]               # List active notes (--all includes closed)
#   bn active                       # List active notes
#   bn close                        # Close current branch's note
#   bn prune                        # Close notes whose worktrees no longer exist
#   bn summary|s                    # Dashboard: open todos, blockers, per-branch detail
#   bn status|st                    # One-line status for current branch
#   bn todo|t                       # List open todos across all branches
#   bn refresh|r                    # Fetch, pull, build current branch
#   bn refresh-all|ra               # Refresh all main worktrees
#   bn main|m                       # Print main note dir + list scripts
#   bn build|b [name]               # Run a script (default: build)
#   bn script|sc [new|edit|list]    # Manage repo scripts
#   bn archive [--days N] [--dry-run]  # Archive old closed notes
#   bn clean [--all]                # Remove empty placeholder todos
#   bn worktrees|w                  # All active worktrees with details
#   bn global|g [subcmd]            # Repo-level global note

source "$HOME/.bin/tmux-lib.sh"

# --- Config ---

NOTES_DIR="$HOME/projects/personal-notes/branch-notes"

# --- Helpers: Git Context ---

# Resolve git context and exit on failure. Use instead of bare resolve_note_context.
require_git_context() {
    resolve_note_context "$(pwd)" || { echo "Not in a git repo" >&2; exit 1; }
}

# --- Helpers: Git & Frontmatter ---

# Read machine from frontmatter (empty if missing)
get_note_machine() {
    local note_file="$1"
    sed -n '/^---$/,/^---$/{ /^machine:/s/^machine: *//p; }' "$note_file"
}

# Check if note belongs to current machine (notes without machine field always match)
is_local_note() {
    local note_file="$1"
    local machine
    machine=$(get_note_machine "$note_file")
    [[ -z "$machine" || "$machine" == "$(hostname)" ]]
}

# Read status from frontmatter (defaults to "active" if missing)
get_note_status() {
    local note_file="$1"
    local note_status
    note_status=$(sed -n '/^---$/,/^---$/{ /^status:/s/^status: *//p; }' "$note_file")
    echo "${note_status:-active}"
}

# Set status in frontmatter
set_note_status() {
    local note_file="$1" new_status="$2"
    if grep -q '^status:' "$note_file"; then
        sed -i "s/^status: .*/status: $new_status/" "$note_file"
    else
        # Insert status after created line
        sed -i "/^created:/a\\
status: $new_status" "$note_file"
    fi
}

# --- Helpers: Note Templates ---

_branch_note_template() {
    cat << EOF
---
repo: $NOTE_REPO
branch: $NOTE_BRANCH
created: $(date +%Y-%m-%d)
status: active
machine: $(hostname)
type:
collaborators: []
---

# $NOTE_REPO / $NOTE_BRANCH

## Goal


## Todos
- [ ]

## Blockers
-

## Decisions
-

## To Research
-

## Collaboration
-

## To Ask
-

---
## Windows
EOF
}

_global_note_template() {
    cat << EOF
---
repo: $NOTE_REPO
created: $(date +%Y-%m-%d)
status: active
machine: $(hostname)
---

# $NOTE_REPO (global)

## Goal


## Todos
- [ ]

## Blockers
-

## Decisions
-

## To Research
-

## Collaboration
-

## To Ask
-
EOF
}

# Create note from template if it doesn't exist
ensure_note() {
    local note_dir="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH"
    local note_file="$note_dir/note.md"
    if [[ ! -f "$note_file" ]]; then
        mkdir -p "$note_dir"
        _branch_note_template > "$note_file"
    fi
    ensure_scripts_dir "$NOTE_REPO"
}

# Create repo-level global note if it doesn't exist
ensure_global_note() {
    local note_file="$NOTES_DIR/$NOTE_REPO/note.md"
    if [[ ! -f "$note_file" ]]; then
        mkdir -p "$NOTES_DIR/$NOTE_REPO"
        _global_note_template > "$note_file"
    fi
}

# --- Helpers: Scripts ---

# Resolve path to a named script (always in main's note dir)
resolve_script() {
    local repo="$1" name="$2"
    echo "$NOTES_DIR/$repo/main/scripts/$name"
}

# Ensure scripts/ dir exists; auto-migrate old build.sh on first access
ensure_scripts_dir() {
    local repo="$1"
    local scripts_dir="$NOTES_DIR/$repo/main/scripts"
    local old_build_sh="$NOTES_DIR/$repo/main/build.sh"

    mkdir -p "$scripts_dir"

    # Migrate old build.sh → scripts/build
    if [[ -f "$old_build_sh" ]]; then
        if grep -q "# bn-placeholder: no build configured" "$old_build_sh" 2>/dev/null; then
            rm "$old_build_sh"
        else
            mv "$old_build_sh" "$scripts_dir/build"
            echo "Migrated build.sh → scripts/build for $repo" >&2
        fi
    fi
}

# Run a named script if it exists, with cwd set to given directory
run_script() {
    local repo="$1" name="$2" work_dir="$3"
    local script
    script=$(resolve_script "$repo" "$name")
    if [[ -x "$script" ]]; then
        echo "Running scripts/$name for $repo..."
        (cd "$work_dir" && "$script")
        return $?
    fi
    return 0
}

# --- Helpers: Section Manipulation ---

# Map short section name to heading
section_heading() {
    case "$1" in
        todo|todos)         echo "## Todos" ;;
        blocker|blockers)   echo "## Blockers" ;;
        decision|decisions) echo "## Decisions" ;;
        research)           echo "## To Research" ;;
        collab)             echo "## Collaboration" ;;
        ask)                echo "## To Ask" ;;
        *) echo "" ;;
    esac
}

# Format line based on section type
format_line() {
    local section="$1" text="$2"
    case "$section" in
        todo|todos) echo "- [ ] $text" ;;
        *)          echo "- $text" ;;
    esac
}

# Insert a line into the correct section of a note
insert_into_section() {
    local note_file="$1" heading="$2" line="$3"

    local heading_line
    heading_line=$(grep -n "^${heading}$" "$note_file" | head -1 | cut -d: -f1)
    [[ -z "$heading_line" ]] && { echo "Section '$heading' not found in note" >&2; return 1; }

    local after_heading=$((heading_line + 1))
    local next_heading_rel
    next_heading_rel=$(tail -n +$after_heading "$note_file" | grep -n '^## \|^---$' | head -1 | cut -d: -f1)

    if [[ -n "$next_heading_rel" ]]; then
        local insert_at=$((heading_line + next_heading_rel - 1))
        # Insert blank line + content before the next heading
        perl -i -pe "print \"${line}\n\" if \$. == ${insert_at}" "$note_file"
    else
        echo "$line" >> "$note_file"
    fi
}

# Extract non-placeholder items from a named section of a note file.
# Todos:   skips bare "- [ ]" and "- [ ] test"
# Others:  skips bare "-" lines
# Prints one item per line; returns 1 if section is empty/missing.
_section_items() {
    local note_file="$1" heading="$2"
    local -a items
    # Capture lines between the heading and the next heading/frontmatter fence
    while IFS= read -r line; do
        [[ -n "$line" ]] && items+=("$line")
    done <<< "$(awk "/^${heading}\$/{found=1; next} /^## |^---\$/{found=0} found && /^- /" "$note_file" 2>/dev/null)"

    # Filter out placeholders
    local -a real
    for item in "${items[@]}"; do
        # Skip bare todo placeholder and bare bullet
        [[ "$item" =~ '^- \[ \]( test)?$' ]] && continue
        [[ "$item" == "-" ]] && continue
        real+=("$item")
    done

    (( ${#real[@]} == 0 )) && return 1
    for item in "${real[@]}"; do
        echo "  $item"
    done
}

# Remove placeholder lines from a note file:
#   todos:  bare "- [ ]" or "- [ ] test"
#   others: bare "-" lines
_clean_note() {
    local note_file="$1"
    local before after
    before=$(grep -cE '^- \[ \]( test)?$|^-$' "$note_file" 2>/dev/null || true)
    (( before == 0 )) && return 0
    sed -i -E '/^- \[ \]( test)?$/d; /^-$/d' "$note_file"
    after=$(grep -cE '^- \[ \]( test)?$|^-$' "$note_file" 2>/dev/null || true)
    echo "  Removed $(( before - after )) placeholder(s)"
}

# --- Commands ---

cmd_path() {
    require_git_context
    echo "$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH"
}

cmd_cat() {
    require_git_context
    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    # Auto-prune: if note is active, repo is bare-based, and worktree is gone
    if [[ -f "$note_file" && -d "$BARE_DIR/${NOTE_REPO}.git" ]]; then
        local wt_path="$WORKTREE_DIR/${NOTE_REPO}/${NOTE_BRANCH}"
        if [[ ! -d "$wt_path" ]] && [[ "$(get_note_status "$note_file")" == "active" ]]; then
            set_note_status "$note_file" "closed"
            echo "Auto-closed: $NOTE_REPO/$NOTE_BRANCH (worktree removed)" >&2
        fi
    fi
    local file="${1:-note.md}"
    cat "$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/$file"
}

cmd_edit() {
    require_git_context
    ensure_note
    local file="${1:-note.md}"
    ${EDITOR:-nvim} "$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/$file"
}

cmd_default() {
    require_git_context
    ensure_note
    echo "$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH"
}

# Add a line to a section
cmd_add() {
    local section="$1"
    [[ -z "$section" ]] && { echo "Usage: branch-note add <section> <text>" >&2; exit 1; }
    shift
    local text="$*"
    [[ -z "$text" ]] && { echo "Usage: branch-note add <section> <text>" >&2; exit 1; }

    local heading
    heading=$(section_heading "$section")
    [[ -z "$heading" ]] && { echo "Unknown section: $section (use: todo, blocker, decision, research, collab, ask)" >&2; exit 1; }

    require_git_context
    ensure_note

    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    local line
    line=$(format_line "$section" "$text")

    insert_into_section "$note_file" "$heading" "$line"
    echo "Added to ${heading#\#\# }: $text"
}

# List notes across repos (active + local machine by default)
cmd_list() {
    local show_all=false
    local all_machines=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --all) show_all=true; shift ;;
            --all-machines) all_machines=true; shift ;;
            *) shift ;;
        esac
    done

    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local found=false
    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        local note_status=$(get_note_status "$note_file")
        if ! $show_all && [[ "$note_status" == "closed" ]]; then
            continue
        fi

        if ! $all_machines && ! is_local_note "$note_file"; then
            continue
        fi

        found=true
        local note_dir=$(dirname "$note_file")
        local branch=$(basename "$note_dir")
        local repo=$(basename "$(dirname "$note_dir")")

        local type=""
        type=$(sed -n '/^---$/,/^---$/{ /^type:/s/^type: *//p; }' "$note_file")
        [[ -z "$type" ]] && type="-"

        local todos=0
        todos=$(grep -c '^\- \[ \]' "$note_file" 2>/dev/null || true)

        local created=""
        created=$(sed -n '/^---$/,/^---$/{ /^created:/s/^created: *//p; }' "$note_file")

        local machine=""
        machine=$(get_note_machine "$note_file")

        local note_status_tag=""
        [[ "$note_status" == "closed" ]] && note_status_tag=" (closed)"

        local machine_tag=""
        [[ -n "$machine" ]] && machine_tag=" [$machine]"

        printf "%-30s %-12s %d todos  %s%s%s\n" "$repo/$branch" "$type" "$todos" "$created" "$note_status_tag" "$machine_tag"
    done

    $found || echo "No branch notes found"
}

# Close current branch's note
cmd_close() {
    require_git_context
    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    [[ ! -f "$note_file" ]] && { echo "No note for $NOTE_REPO/$NOTE_BRANCH" >&2; exit 1; }

    set_note_status "$note_file" "closed"
    echo "Closed note: $NOTE_REPO/$NOTE_BRANCH"
}

# Close notes whose worktrees no longer exist
cmd_prune() {
    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local closed=0
    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        local note_status=$(get_note_status "$note_file")
        [[ "$note_status" == "closed" ]] && continue

        local note_dir=$(dirname "$note_file")
        local branch=$(basename "$note_dir")
        local repo=$(basename "$(dirname "$note_dir")")

        # Only prune worktree-based repos (those with a bare repo)
        [[ ! -d "$BARE_DIR/${repo}.git" ]] && continue

        local worktree_path="$WORKTREE_DIR/${repo}/${branch}"
        if [[ ! -d "$worktree_path" ]]; then
            set_note_status "$note_file" "closed"
            echo "Closed: $repo/$branch (worktree removed)"
            closed=$((closed + 1))
        fi
    done

    (( closed == 0 )) && echo "Nothing to prune"

    # Auto-archive old closed notes
    cmd_archive
}

# Summary dashboard
cmd_summary() {
    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local total_todos=0
    local total_blockers=0
    local details=""
    local found=false

    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        local note_status=$(get_note_status "$note_file")
        [[ "$note_status" == "closed" ]] && continue
        is_local_note "$note_file" || continue

        found=true
        local note_dir=$(dirname "$note_file")
        local branch=$(basename "$note_dir")
        local repo=$(basename "$(dirname "$note_dir")")

        local type=""
        type=$(sed -n '/^---$/,/^---$/{ /^type:/s/^type: *//p; }' "$note_file")
        [[ -z "$type" ]] && type="-"

        local todos=0
        todos=$(grep -c '^\- \[ \]' "$note_file" 2>/dev/null || true)
        total_todos=$((total_todos + todos))

        # Count non-empty blocker lines
        local blockers=0
        blockers=$(awk '/^## Blockers$/{found=1; next} /^## |^---$/{found=0} found && /^- ./' "$note_file" | wc -l | tr -d ' ')
        total_blockers=$((total_blockers + blockers))

        # Build per-branch detail
        local header="\n$repo/$branch ($type, $todos todos"
        (( blockers > 0 )) && header="$header, $blockers blockers"
        header="$header)"

        local items=""
        # Collect open todos
        while IFS= read -r line; do
            [[ -n "$line" ]] && items="$items\n  ${line#- }"
        done <<< "$(grep '^\- \[ \]' "$note_file" 2>/dev/null)"

        # Collect blockers
        while IFS= read -r line; do
            [[ -n "$line" ]] && items="$items\n  [!] ${line#- }"
        done <<< "$(awk '/^## Blockers$/{found=1; next} /^## |^---$/{found=0} found && /^- ./' "$note_file" 2>/dev/null)"

        if (( todos > 0 )) || (( blockers > 0 )); then
            details="$details$header$items"
        fi
    done

    if $found; then
        echo "Open todos across all branches: $total_todos"
        echo "Blockers: $total_blockers"
        [[ -n "$details" ]] && print "$details"
    else
        echo "No branch notes found"
    fi
}

# Refresh current branch: fetch, pull, build
cmd_refresh() {
    require_git_context

    local worktree_path
    worktree_path=$(pwd)
    local bare_repo="$BARE_DIR/${NOTE_REPO}.git"

    echo "Fetching origin for $NOTE_REPO..."
    if [[ -d "$bare_repo" ]]; then
        git --git-dir="$bare_repo" fetch origin
    else
        git -C "$worktree_path" fetch origin
    fi

    echo "Pulling $NOTE_BRANCH (ff-only)..."
    git -C "$worktree_path" pull --ff-only

    run_script "$NOTE_REPO" "build" "$worktree_path"
    echo "Refresh complete: $NOTE_REPO/$NOTE_BRANCH"
}

# Refresh all main worktrees: parallel fetch (batched), sequential update+build
cmd_refresh_all() {
    local bare_repos=("$BARE_DIR"/*.git(N/))
    [[ ${#bare_repos[@]} -eq 0 ]] && { echo "No bare repos found"; exit 0; }

    local updated=0 skipped=0 failed=0
    local batch_size=4

    # Phase 1: batched parallel fetch (avoid SSH rate limits)
    echo -e "${BLUE}Fetching ${#bare_repos[@]} repos (batch size $batch_size)...${NC}"
    local count=0
    local pids=()
    for bare in "${bare_repos[@]}"; do
        git --git-dir="$bare" fetch origin 2>/dev/null &
        pids+=($!)
        count=$((count + 1))
        if (( count % batch_size == 0 )); then
            for pid in "${pids[@]}"; do wait "$pid" 2>/dev/null; done
            pids=()
        fi
    done
    # Wait for remaining
    for pid in "${pids[@]}"; do wait "$pid" 2>/dev/null; done
    echo -e "${GREEN}Fetch complete.${NC}"

    # Phase 2: sequential update + build
    for bare in "${bare_repos[@]}"; do
        local repo_name=$(basename "$bare" .git)
        local main_wt="$WORKTREE_DIR/${repo_name}/main"

        if [[ ! -d "$main_wt" ]]; then
            echo -e "  ${YELLOW}${repo_name}: no main worktree, skipping${NC}"
            skipped=$((skipped + 1))
            continue
        fi

        echo -e "  ${BLUE}${repo_name}: updating main...${NC}"

        if git -C "$main_wt" merge --ff-only origin/main 2>/dev/null; then
            if run_script "$repo_name" "build" "$main_wt"; then
                echo -e "  ${GREEN}${repo_name}: updated${NC}"
                updated=$((updated + 1))
            else
                echo -e "  ${RED}${repo_name}: build failed${NC}"
                failed=$((failed + 1))
            fi
        else
            echo -e "  ${RED}${repo_name}: pull failed (not fast-forwardable?)${NC}"
            failed=$((failed + 1))
        fi
    done

    echo ""
    echo -e "Summary: ${GREEN}$updated updated${NC}, ${YELLOW}$skipped skipped${NC}, ${RED}$failed failed${NC}"
}

# Print main note dir path + list available scripts
cmd_main() {
    require_git_context
    ensure_scripts_dir "$NOTE_REPO"
    local main_dir="$NOTES_DIR/$NOTE_REPO/main"
    echo "$main_dir"

    local scripts_dir="$main_dir/scripts"
    local -a scripts
    for f in "$scripts_dir"/*(Nx); do
        scripts+=("$(basename "$f")")
    done
    if (( ${#scripts[@]} > 0 )); then
        echo ""
        echo "Scripts:"
        for s in "${scripts[@]}"; do
            echo "  $s"
        done
    else
        echo ""
        echo "No scripts yet. Create one with: bn script new <name>"
    fi
}

# Run a named script (default: build)
cmd_build() {
    local name="${1:-build}"
    require_git_context
    ensure_scripts_dir "$NOTE_REPO"

    local script
    script=$(resolve_script "$NOTE_REPO" "$name")
    if [[ ! -f "$script" ]]; then
        echo "No script '$name' for $NOTE_REPO" >&2
        echo "Create one with: bn script new $name" >&2
        exit 1
    fi
    if [[ ! -x "$script" ]]; then
        chmod +x "$script"
    fi

    local work_dir
    work_dir=$(pwd)
    echo "Running scripts/$name for $NOTE_REPO..."
    (cd "$work_dir" && "$script")
}

# Script management: new, edit, list
cmd_script() {
    local subcmd="${1:-}"
    shift 2>/dev/null || true

    case "$subcmd" in
        new)
            local name="$1"
            [[ -z "$name" ]] && { echo "Usage: bn script new <name>" >&2; exit 1; }
            require_git_context
            ensure_scripts_dir "$NOTE_REPO"

            local script
            script=$(resolve_script "$NOTE_REPO" "$name")
            if [[ -f "$script" ]]; then
                echo "Script '$name' already exists: $script" >&2
                echo "Use 'bn script edit $name' to modify it." >&2
                exit 1
            fi

            cat > "$script" << SCRIPTEOF
#!/usr/bin/env zsh
set -e

# $name script for $NOTE_REPO
# Runs with cwd set to the repo/worktree directory.

SCRIPTEOF
            chmod +x "$script"
            echo "Created: $script"
            echo "Edit with: bn script edit $name"
            ;;
        edit)
            local name="$1"
            [[ -z "$name" ]] && { echo "Usage: bn script edit <name>" >&2; exit 1; }
            require_git_context
            ensure_scripts_dir "$NOTE_REPO"

            local script
            script=$(resolve_script "$NOTE_REPO" "$name")
            if [[ ! -f "$script" ]]; then
                echo "No script '$name' for $NOTE_REPO. Create one with: bn script new $name" >&2
                exit 1
            fi
            ${EDITOR:-nvim} "$script"
            ;;
        list|l|"")
            require_git_context
            ensure_scripts_dir "$NOTE_REPO"

            local scripts_dir="$NOTES_DIR/$NOTE_REPO/main/scripts"
            local -a scripts
            for f in "$scripts_dir"/*(Nx); do
                scripts+=("$(basename "$f")")
            done
            if (( ${#scripts[@]} > 0 )); then
                echo "Scripts for $NOTE_REPO:"
                for s in "${scripts[@]}"; do
                    echo "  $s"
                done
            else
                echo "No scripts for $NOTE_REPO"
                echo "Create one with: bn script new <name>"
            fi
            ;;
        *)
            echo "Usage: bn script [new <name>|edit <name>|list]" >&2
            exit 1
            ;;
    esac
}

# Status: one-line summary for current branch
cmd_status() {
    require_git_context
    local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md"
    if [[ ! -f "$note_file" ]]; then
        echo "$NOTE_REPO/$NOTE_BRANCH: no note"
        return
    fi

    local todos=0 blockers=0
    todos=$(grep -c '^\- \[ \]' "$note_file" 2>/dev/null || true)
    blockers=$(awk '/^## Blockers$/{found=1; next} /^## |^---$/{found=0} found && /^- ./' "$note_file" | wc -l | tr -d ' ')

    local parts=()
    (( todos > 0 )) && parts+=("${todos} todo$( (( todos != 1 )) && echo s)")
    (( blockers > 0 )) && parts+=("${blockers} blocker$( (( blockers != 1 )) && echo s)")
    if [[ ${#parts[@]} -eq 0 ]]; then
        echo "$NOTE_REPO/$NOTE_BRANCH: clear"
    else
        echo "$NOTE_REPO/$NOTE_BRANCH: ${(j:, :)parts}"
    fi
}

# Todo: list open todos across all active branches
cmd_todo() {
    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local found=false
    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        local note_status=$(get_note_status "$note_file")
        [[ "$note_status" == "closed" ]] && continue
        is_local_note "$note_file" || continue

        local todos=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && todos+=("$line")
        done <<< "$(grep '^\- \[ \]' "$note_file" 2>/dev/null)"

        [[ ${#todos[@]} -eq 0 ]] && continue

        found=true
        local note_dir=$(dirname "$note_file")
        local branch=$(basename "$note_dir")
        local repo=$(basename "$(dirname "$note_dir")")

        echo -e "${BLUE}${repo}/${branch}${NC}"
        for todo in "${todos[@]}"; do
            echo "  $todo"
        done
    done

    $found || echo "No open todos"
}

# Archive closed notes older than N days
cmd_archive() {
    local days=30
    local dry_run=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --days) days="$2"; shift 2 ;;
            --dry-run) dry_run=true; shift ;;
            *) echo "Unknown option: $1" >&2; exit 1 ;;
        esac
    done

    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local cutoff
    cutoff=$(date -v-${days}d '+%Y-%m-%d')

    local archived=0
    local -a affected_paths=()

    if $dry_run; then
        echo -e "${YELLOW}[DRY RUN — no changes will be made]${NC}"
        echo ""
    fi

    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        local note_status=$(get_note_status "$note_file")
        [[ "$note_status" != "closed" ]] && continue

        local created=$(sed -n '/^---$/,/^---$/{ /^created:/s/^created: *//p; }' "$note_file")
        [[ -z "$created" ]] && continue
        [[ "$created" > "$cutoff" ]] && continue

        local note_dir=$(dirname "$note_file")
        local branch=$(basename "$note_dir")
        local repo=$(basename "$(dirname "$note_dir")")

        local dest="$NOTES_DIR/archive/$repo/$branch"

        if [[ -d "$dest" ]]; then
            echo -e "${RED}Already exists, skipping: archive/$repo/$branch${NC}" >&2
            continue
        fi

        echo -e "${YELLOW}Archive: $repo/$branch${NC} (created $created)"

        if ! $dry_run; then
            mkdir -p "$(dirname "$dest")"
            mv "$note_dir" "$dest"
            archived=$((archived + 1))
            affected_paths+=("$repo/$branch")

            # Clean up empty repo dir
            local repo_dir="$NOTES_DIR/$repo"
            if [[ -d "$repo_dir" ]] && [[ -z "$(ls -A "$repo_dir")" ]]; then
                rmdir "$repo_dir"
            fi
        else
            archived=$((archived + 1))
        fi
    done

    echo ""
    if $dry_run; then
        echo -e "${GREEN}Would archive: $archived note(s)${NC}"
    else
        echo -e "${GREEN}Archived: $archived note(s)${NC}"

        # Auto-commit only the moved note directories
        if (( archived > 0 )); then
            for p in "${affected_paths[@]}"; do
                git -C "$NOTES_DIR" add -- "archive/$p"
                git -C "$NOTES_DIR" rm -r --cached --ignore-unmatch --quiet -- "$p"
            done
            git -C "$NOTES_DIR" diff --cached --quiet || {
                git -C "$NOTES_DIR" commit -m "archive ${archived} note(s)" >/dev/null
                echo -e "${GREEN}Committed to personal-notes${NC}"
            }
        fi
    fi
}

# Strip placeholder lines from notes
cmd_clean() {
    local all=false
    [[ "${1:-}" == "--all" ]] && all=true

    if $all; then
        [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }
        local cleaned=0 note_status note_dir branch repo count
        for note_file in "$NOTES_DIR"/*/*/note.md(N); do
            note_status=$(get_note_status "$note_file")
            [[ "$note_status" == "closed" ]] && continue
            note_dir=$(dirname "$note_file")
            branch=$(basename "$note_dir")
            repo=$(basename "$(dirname "$note_dir")")
            count=$(grep -cE '^- \[ \]( test)?$|^-$' "$note_file" 2>/dev/null || true)
            (( count == 0 )) && continue
            echo "${repo}/${branch}:"
            _clean_note "$note_file"
            cleaned=$(( cleaned + count ))
        done
        (( cleaned == 0 )) && echo "No placeholders found" || print "\nTotal removed: $cleaned"
    else
        require_git_context
        local note_file="$NOTES_DIR/$NOTE_REPO/$NOTE_BRANCH/note.md" count
        [[ ! -f "$note_file" ]] && { echo "No note for $NOTE_REPO/$NOTE_BRANCH" >&2; exit 1; }
        count=$(grep -cE '^- \[ \]( test)?$|^-$' "$note_file" 2>/dev/null || true)
        if (( count == 0 )); then
            echo "No placeholders in $NOTE_REPO/$NOTE_BRANCH"
        else
            echo "$NOTE_REPO/$NOTE_BRANCH:"
            _clean_note "$note_file"
        fi
    fi
}

# All active worktrees with todos, blockers, research, decisions, and questions
cmd_worktrees() {
    [[ ! -d "$NOTES_DIR" ]] && { echo "No branch notes found"; exit 0; }

    local found=false total_todos=0 out
    local note_status note_dir branch repo created type meta todo_count
    local -a todos

    for note_file in "$NOTES_DIR"/*/*/note.md(N); do
        note_status=$(get_note_status "$note_file")
        [[ "$note_status" == "closed" ]] && continue
        is_local_note "$note_file" || continue

        found=true
        note_dir=$(dirname "$note_file")
        branch=$(basename "$note_dir")
        repo=$(basename "$(dirname "$note_dir")")
        created=$(sed -n '/^---$/,/^---$/{ /^created:/s/^created: *//p; }' "$note_file")
        type=$(sed -n '/^---$/,/^---$/{ /^type:/s/^type: *//p; }' "$note_file")

        todos=()
        while IFS= read -r line; do
            [[ -n "$line" ]] && todos+=("$line")
        done <<< "$(_section_items "$note_file" "## Todos" 2>/dev/null)"

        todo_count=${#todos[@]}
        total_todos=$(( total_todos + todo_count ))

        meta="${created}"
        [[ -n "$type" ]] && meta="${meta}  ${type}"
        echo -e "${BLUE}${repo}/${branch}${NC}  ${meta}"

        if (( todo_count > 0 )); then
            echo -e "  ${YELLOW}Todos${NC}"
            for todo in "${todos[@]}"; do echo "$todo"; done
        fi

        out=$(_section_items "$note_file" "## Blockers") && {
            echo -e "  ${RED}Blockers${NC}"
            echo "$out"
        }
        out=$(_section_items "$note_file" "## To Research") && {
            echo -e "  ${GREEN}Research${NC}"
            echo "$out"
        }
        out=$(_section_items "$note_file" "## Decisions") && {
            echo -e "  ${YELLOW}Decisions${NC}"
            echo "$out"
        }
        out=$(_section_items "$note_file" "## To Ask") && {
            echo -e "  ${NC}To Ask${NC}"
            echo "$out"
        }
        echo ""
    done

    if $found; then
        echo -e "${GREEN}Total open todos: ${total_todos}${NC}"
    else
        echo "No active branch notes found"
    fi
}

# Repo-level global note (not branch-specific)
cmd_global() {
    require_git_context
    local subcmd="${1:-}"
    shift 2>/dev/null || true

    case "$subcmd" in
        --cat|"")
            ensure_global_note
            cat "$NOTES_DIR/$NOTE_REPO/note.md"
            ;;
        --edit)
            ensure_global_note
            ${EDITOR:-nvim} "$NOTES_DIR/$NOTE_REPO/note.md"
            ;;
        --path)
            echo "$NOTES_DIR/$NOTE_REPO"
            ;;
        add)
            local section="$1"; shift
            local text="$*"
            [[ -z "$section" || -z "$text" ]] && { echo "Usage: bn global add <section> <text>" >&2; exit 1; }
            local heading
            heading=$(section_heading "$section")
            [[ -z "$heading" ]] && { echo "Unknown section: $section" >&2; exit 1; }
            ensure_global_note
            local note_file="$NOTES_DIR/$NOTE_REPO/note.md"
            local line
            line=$(format_line "$section" "$text")
            insert_into_section "$note_file" "$heading" "$line"
            echo "Added to ${heading#\#\# } (global/$NOTE_REPO): $text"
            ;;
        *)
            echo "Usage: bn global [--cat|--edit|--path|add <section> <text>]" >&2
            exit 1
            ;;
    esac
}

cmd_help() {
    cat << 'HELPEOF'
Usage: bn [command]

Commands:
  (none)                          Ensure note exists, print dir path
  --path, -p                      Print note dir path (no create)
  --cat, -c [file]                Print note.md (or specific file)
  --edit, -e [file]               Open note in $EDITOR
  add, a <section> <text>         Add line to section
  list, l [--all] [--all-machines] List active notes
  active                          List active notes (same as list)
  close                           Close current branch's note
  prune                           Close notes whose worktrees are gone
  summary, s                      Dashboard of active work
  status, st                      One-line status for current branch
  todo, t                         List open todos across all branches
  refresh, r                      Fetch, pull, build current branch
  refresh-all, ra                 Refresh all main worktrees
  main, m                         Print main note dir + list scripts
  build, b [name]                 Run a script (default: build)
  script, sc [new|edit|list]      Manage repo scripts
  archive [--days N] [--dry-run]  Archive closed notes older than N days (default 30)
  clean [--all]                   Remove empty placeholder todos
  worktrees, w                    All active worktrees with full todo lists
  global, g [--cat|--edit|--path] Repo-level global note (not branch-specific)
  global add <section> <text>     Add to repo global note

Scripts:
  Scripts live in <notes>/<repo>/main/scripts/ and run with cwd = repo dir.
  Use 'bn script new <name>' to create, 'bn script edit <name>' to modify.

Filtering:
  By default, list/summary/todo/worktrees only show notes for this machine.
  Notes without a machine field are always shown.
  Use --all-machines with list to see notes from all hosts.

Sections: todo, blocker, decision, research, collab, ask
HELPEOF
}

# --- Dispatch ---

case "${1:-}" in
    --path|-p)          cmd_path ;;
    --cat|-c)           shift; cmd_cat "$@" ;;
    --edit|-e)          shift; cmd_edit "$@" ;;
    add|a)              shift; cmd_add "$@" ;;
    list|l)             shift; cmd_list "$@" ;;
    active)             cmd_list ;;
    close)              cmd_close ;;
    prune)              cmd_prune ;;
    summary|s)          cmd_summary ;;
    status|st)          cmd_status ;;
    todo|todos|t)       cmd_todo ;;
    refresh|r)          cmd_refresh ;;
    refresh-all|ra)     cmd_refresh_all ;;
    main|m)             cmd_main ;;
    build|b)            shift; cmd_build "$@" ;;
    script|sc)          shift; cmd_script "$@" ;;
    archive)            shift; cmd_archive "$@" ;;
    clean)              shift; cmd_clean "$@" ;;
    worktrees|w)        cmd_worktrees ;;
    global|g)           shift; cmd_global "$@" ;;
    -h|--help|help)     cmd_help ;;
    "")                 cmd_default ;;
    *)                  echo "Unknown command: $1" >&2; exit 1 ;;
esac
